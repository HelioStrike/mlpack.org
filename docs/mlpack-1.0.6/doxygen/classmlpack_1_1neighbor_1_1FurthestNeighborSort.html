<html >
<head >

<meta name="keywords" content="mlpack, libmlpack, c++, armadillo, machine
learning, data mining, classification, regression, tree-based methods, dual-tree
algorithm">
<meta name="description" content="mlpack: a scalable c++ machine learning
library">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title >mlpack: a scalable c++ machine learning library</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="dynamic_tables.js"></script>
</head><link rel="stylesheet" href="style-doxygen.css" /><link rel="stylesheet" href="doxygen.css" /><link rel="stylesheet" href="tabs.css" /><link rel="stylesheet" href="search/search.css" /><link href="http://fonts.googleapis.com/css?family=Maven+Pro:500" rel="stylesheet" type="text/css" />





<body ><br />


<div class="mlpack_titlebar">
   <a href="http://www.mlpack.org"><img src="../../../mlpack.png"></a>
</div>
<center >
<div class="mlnavbar">
  <div class="navcontainer">
   <div class="mlnavitem" name="mlnavmain"><a href="../../../index.html">main</a></div>
   <div class="mlnavitem" name="mlnavabout"><a href="../../../about.html">about</a></div>
   <div class="mlnavitem" name="mlnavdoc"><a href="../../../docs.html">docs</a></div>
   <div class="mlnavitem" name="mlnavhelp"><a href="../../../help.html">get help</a></div>
   <div class="mlnavitem" name="mlnavbugs"><a href="https://github.com/mlpack/mlpack">github</a></div>
  </div>
</div>
</center>
<div class="separator"></div>
<center >
<div class="mainsection smallertext">
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody >
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLPACK
   &#160;<span id="projectnumber">1.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>

<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul >
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1neighbor.html">neighbor</a></li><li class="navelem"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html">FurthestNeighborSort</a></li>  </ul>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlpack_1_1neighbor_1_1FurthestNeighborSort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::neighbor::FurthestNeighborSort Class Reference</div>  </div>
</div>
<div class="contents">

<p >This class implements the necessary methods for the SortPolicy template parameter of the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> class.  
 <a href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a24e85dec805cc1f264a138501ee24731"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#a24e85dec805cc1f264a138501ee24731">BestDistance</a> ()</td></tr>
<tr class="memdesc:a24e85dec805cc1f264a138501ee24731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return what should represent the best possible distance with this particular sort policy.  <a href="#a24e85dec805cc1f264a138501ee24731">More...</a><br /></br></td></tr>
<tr class="separator:a24e85dec805cc1f264a138501ee24731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae51f34ae4b6cc8e680e11419ecbefe2"><td class="memTemplParams" colspan="2"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></td></tr>
<tr class="memitem:aae51f34ae4b6cc8e680e11419ecbefe2"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#aae51f34ae4b6cc8e680e11419ecbefe2">BestNodeToNodeDistance</a> (const TreeType *queryNode, const TreeType *referenceNode)</td></tr>
<tr class="memdesc:aae51f34ae4b6cc8e680e11419ecbefe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best possible distance between two nodes.  <a href="#aae51f34ae4b6cc8e680e11419ecbefe2">More...</a><br /></br></td></tr>
<tr class="separator:aae51f34ae4b6cc8e680e11419ecbefe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33c263a2ad24c6aa1b1f812b1328200"><td class="memTemplParams" colspan="2"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></td></tr>
<tr class="memitem:ac33c263a2ad24c6aa1b1f812b1328200"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#ac33c263a2ad24c6aa1b1f812b1328200">BestNodeToNodeDistance</a> (const TreeType *queryNode, const TreeType *referenceNode, const double centerToCenterDistance)</td></tr>
<tr class="memdesc:ac33c263a2ad24c6aa1b1f812b1328200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best possible distance between two nodes, given that the distance between the centers of the two nodes has already been calculated.  <a href="#ac33c263a2ad24c6aa1b1f812b1328200">More...</a><br /></br></td></tr>
<tr class="separator:ac33c263a2ad24c6aa1b1f812b1328200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2723d2714fb8ef4eb2823f8f0e1d236f"><td class="memTemplParams" colspan="2"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></td></tr>
<tr class="memitem:a2723d2714fb8ef4eb2823f8f0e1d236f"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#a2723d2714fb8ef4eb2823f8f0e1d236f">BestNodeToNodeDistance</a> (const TreeType *queryNode, const TreeType *referenceNode, const TreeType *referenceChildNode, const double centerToCenterDistance)</td></tr>
<tr class="memdesc:a2723d2714fb8ef4eb2823f8f0e1d236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best possible distance between the query node and the reference child node given the base case distance between the query node and the reference node.  <a href="#a2723d2714fb8ef4eb2823f8f0e1d236f">More...</a><br /></br></td></tr>
<tr class="separator:a2723d2714fb8ef4eb2823f8f0e1d236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab592843884e0ed3ec1958c98264f5a5f"><td class="memTemplParams" colspan="2"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></td></tr>
<tr class="memitem:ab592843884e0ed3ec1958c98264f5a5f"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#ab592843884e0ed3ec1958c98264f5a5f">BestPointToNodeDistance</a> (const arma::vec &amp;queryPoint, const TreeType *referenceNode)</td></tr>
<tr class="memdesc:ab592843884e0ed3ec1958c98264f5a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best possible distance between a node and a point.  <a href="#ab592843884e0ed3ec1958c98264f5a5f">More...</a><br /></br></td></tr>
<tr class="separator:ab592843884e0ed3ec1958c98264f5a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ede45ceed5be3c93ad535d6f195fb2a"><td class="memTemplParams" colspan="2"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></td></tr>
<tr class="memitem:a0ede45ceed5be3c93ad535d6f195fb2a"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#a0ede45ceed5be3c93ad535d6f195fb2a">BestPointToNodeDistance</a> (const arma::vec &amp;queryPoint, const TreeType *referenceNode, const double pointToCenterDistance)</td></tr>
<tr class="memdesc:a0ede45ceed5be3c93ad535d6f195fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best possible distance between a point and a node, given that the distance between the point and the center of the node has already been calculated.  <a href="#a0ede45ceed5be3c93ad535d6f195fb2a">More...</a><br /></br></td></tr>
<tr class="separator:a0ede45ceed5be3c93ad535d6f195fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b9d3ccb95d1735442bffbfee0482d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#a047b9d3ccb95d1735442bffbfee0482d">CombineWorst</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a047b9d3ccb95d1735442bffbfee0482d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the worst combination of the two distances.  <a href="#a047b9d3ccb95d1735442bffbfee0482d">More...</a><br /></br></td></tr>
<tr class="separator:a047b9d3ccb95d1735442bffbfee0482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad958c571e89184874ef8cd8675d563e7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#ad958c571e89184874ef8cd8675d563e7">IsBetter</a> (const double value, const double ref)</td></tr>
<tr class="memdesc:ad958c571e89184874ef8cd8675d563e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether or not value is "better" than ref.  <a href="#ad958c571e89184874ef8cd8675d563e7">More...</a><br /></br></td></tr>
<tr class="separator:ad958c571e89184874ef8cd8675d563e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4985b980e36a5f116cd5fb1a7d7c87b7"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#a4985b980e36a5f116cd5fb1a7d7c87b7">SortDistance</a> (const arma::vec &amp;list, double newDistance)</td></tr>
<tr class="memdesc:a4985b980e36a5f116cd5fb1a7d7c87b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index in the vector where the new distance should be inserted, or size_t() - 1 if it should not be inserted (i.e.  <a href="#a4985b980e36a5f116cd5fb1a7d7c87b7">More...</a><br /></br></td></tr>
<tr class="separator:a4985b980e36a5f116cd5fb1a7d7c87b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7d6c7a4077d3573e4e4b39c9f190d9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#aba7d6c7a4077d3573e4e4b39c9f190d9">WorstDistance</a> ()</td></tr>
<tr class="memdesc:aba7d6c7a4077d3573e4e4b39c9f190d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return what should represent the worst possible distance with this particular sort policy.  <a href="#aba7d6c7a4077d3573e4e4b39c9f190d9">More...</a><br /></br></td></tr>
<tr class="separator:aba7d6c7a4077d3573e4e4b39c9f190d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This class implements the necessary methods for the SortPolicy template parameter of the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> class. </p>
<p >The sorting policy here is that the minimum distance is the best (so, when used with <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a>, the output is furthest neighbors). </p>

<p class="definition">Definition at line <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00037">37</a> of file <a class="el" href="furthest__neighbor__sort_8hpp_source.html">furthest_neighbor_sort.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a24e85dec805cc1f264a138501ee24731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e85dec805cc1f264a138501ee24731">&#9670;&nbsp;</a></span>BestDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::BestDistance </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return what should represent the best possible distance with this particular sort policy. </p>
<p >In our case, this should be the maximum possible distance, DBL_MAX.</p>
<dl class="section return"><dt >Returns</dt><dd >DBL_MAX </dd></dl>

<p class="definition">Definition at line <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00144">144</a> of file <a class="el" href="furthest__neighbor__sort_8hpp_source.html">furthest_neighbor_sort.hpp</a>.</p>

</div>
</div>
<a id="aae51f34ae4b6cc8e680e11419ecbefe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae51f34ae4b6cc8e680e11419ecbefe2">&#9670;&nbsp;</a></span>BestNodeToNodeDistance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::BestNodeToNodeDistance </td>
          <td >(</td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >queryNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >referenceNode</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the best possible distance between two nodes. </p>
<p >In our case, this is the maximum distance between the two tree nodes using the given distance function. </p>

<p class="reference">Referenced by <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00065">IsBetter()</a>.</p>

</div>
</div>
<a id="ac33c263a2ad24c6aa1b1f812b1328200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33c263a2ad24c6aa1b1f812b1328200">&#9670;&nbsp;</a></span>BestNodeToNodeDistance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::BestNodeToNodeDistance </td>
          <td >(</td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >queryNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >referenceNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >centerToCenterDistance</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the best possible distance between two nodes, given that the distance between the centers of the two nodes has already been calculated. </p>
<p >This is used in conjunction with trees that have self-children (like cover trees). </p>

</div>
</div>
<a id="a2723d2714fb8ef4eb2823f8f0e1d236f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2723d2714fb8ef4eb2823f8f0e1d236f">&#9670;&nbsp;</a></span>BestNodeToNodeDistance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::BestNodeToNodeDistance </td>
          <td >(</td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >queryNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >referenceNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >referenceChildNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >centerToCenterDistance</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the best possible distance between the query node and the reference child node given the base case distance between the query node and the reference node. </p>
<p >TreeType::ParentDistance() must be implemented to use this.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">queryNode</td><td >Query node. </td></tr>
    <tr ><td class="paramname">referenceNode</td><td >Reference node. </td></tr>
    <tr ><td class="paramname">referenceChildNode</td><td >Child of reference node which is being inspected. </td></tr>
    <tr ><td class="paramname">centerToCenterDistance</td><td >Distance between centers of query node and reference node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab592843884e0ed3ec1958c98264f5a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab592843884e0ed3ec1958c98264f5a5f">&#9670;&nbsp;</a></span>BestPointToNodeDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::BestPointToNodeDistance </td>
          <td >(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em >queryPoint</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >referenceNode</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the best possible distance between a node and a point. </p>
<p >In our case, this is the maximum distance between the tree node and the point using the given distance function. </p>

<p class="reference">Referenced by <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00065">IsBetter()</a>.</p>

</div>
</div>
<a id="a0ede45ceed5be3c93ad535d6f195fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ede45ceed5be3c93ad535d6f195fb2a">&#9670;&nbsp;</a></span>BestPointToNodeDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeType</div><div class="close_bracket">&gt;</div></div></div></div></div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::BestPointToNodeDistance </td>
          <td >(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em >queryPoint</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const TreeType *&#160;</td>
          <td class="paramname"><em >referenceNode</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >pointToCenterDistance</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the best possible distance between a point and a node, given that the distance between the point and the center of the node has already been calculated. </p>
<p >This is used in conjunction with trees that have self-children (like cover trees). </p>

</div>
</div>
<a id="a047b9d3ccb95d1735442bffbfee0482d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b9d3ccb95d1735442bffbfee0482d">&#9670;&nbsp;</a></span>CombineWorst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::CombineWorst </td>
          <td >(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >a</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >b</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the worst combination of the two distances. </p>

<p class="definition">Definition at line <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00149">149</a> of file <a class="el" href="furthest__neighbor__sort_8hpp_source.html">furthest_neighbor_sort.hpp</a>.</p>

</div>
</div>
<a id="ad958c571e89184874ef8cd8675d563e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad958c571e89184874ef8cd8675d563e7">&#9670;&nbsp;</a></span>IsBetter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static bool mlpack::neighbor::FurthestNeighborSort::IsBetter </td>
          <td >(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >value</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em >ref</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return whether or not value is "better" than ref. </p>
<p >In this case, that means that the value is greater than the reference.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">value</td><td >Value to compare </td></tr>
    <tr ><td class="paramname">ref</td><td >Value to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt >Returns</dt><dd >bool indicating whether or not (value &gt; ref). </dd></dl>

<p class="definition">Definition at line <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00065">65</a> of file <a class="el" href="furthest__neighbor__sort_8hpp_source.html">furthest_neighbor_sort.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#aae51f34ae4b6cc8e680e11419ecbefe2">BestNodeToNodeDistance()</a>, and <a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html#ab592843884e0ed3ec1958c98264f5a5f">BestPointToNodeDistance()</a>.</p>

</div>
</div>
<a id="a4985b980e36a5f116cd5fb1a7d7c87b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4985b980e36a5f116cd5fb1a7d7c87b7">&#9670;&nbsp;</a></span>SortDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static size_t mlpack::neighbor::FurthestNeighborSort::SortDistance </td>
          <td >(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em >list</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em >newDistance</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the index in the vector where the new distance should be inserted, or size_t() - 1 if it should not be inserted (i.e. </p>
<p >if it is not any better than any of the existing points in the list). The list should be sorted such that the best point is the first in the list. The actual insertion is not performed.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">list</td><td >Vector of existing distance points, sorted such that the best point is the first in the list. </td></tr>
    <tr ><td class="paramname">new_distance</td><td >Distance to try to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt >Returns</dt><dd >size_t containing the position to insert into, or (size_t() - 1) if the new distance should not be inserted. </dd></dl>

</div>
</div>
<a id="aba7d6c7a4077d3573e4e4b39c9f190d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7d6c7a4077d3573e4e4b39c9f190d9">&#9670;&nbsp;</a></span>WorstDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">static double mlpack::neighbor::FurthestNeighborSort::WorstDistance </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return what should represent the worst possible distance with this particular sort policy. </p>
<p >In our case, this should be the minimum possible distance, 0.</p>
<dl class="section return"><dt >Returns</dt><dd >0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="furthest__neighbor__sort_8hpp_source.html#l00135">135</a> of file <a class="el" href="furthest__neighbor__sort_8hpp_source.html">furthest_neighbor_sort.hpp</a>.</p>

</div>
</div>
<hr ></hr>The documentation for this class was generated from the following file:<ul >
<li >/var/www/www.mlpack.org/mlpack-1.0.6/src/mlpack/methods/neighbor_search/sort_policies/<a class="el" href="furthest__neighbor__sort_8hpp_source.html">furthest_neighbor_sort.hpp</a></li>
</ul>
</div>

<hr class="footer"></hr><address class="footer"><small >
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"></img>
</a> 1.8.13
</small></address>
</div>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>