<html >
<head >

<meta name="keywords" content="mlpack, libmlpack, c++, armadillo, machine
learning, data mining, classification, regression, tree-based methods, dual-tree
algorithm">
<meta name="description" content="mlpack: a scalable c++ machine learning
library">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title >mlpack: a scalable c++ machine learning library</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="dynamic_tables.js"></script>
</head><link rel="stylesheet" href="style-doxygen.css" /><link rel="stylesheet" href="doxygen.css" /><link rel="stylesheet" href="tabs.css" /><link rel="stylesheet" href="search/search.css" /><link href="http://fonts.googleapis.com/css?family=Maven+Pro:500" rel="stylesheet" type="text/css" />





<body ><br />


<div class="mlpack_titlebar">
   <a href="http://www.mlpack.org"><img src="../../../mlpack.png"></a>
</div>
<center >
<div class="mlnavbar">
  <div class="navcontainer">
   <div class="mlnavitem" name="mlnavmain"><a href="../../../index.html">main</a></div>
   <div class="mlnavitem" name="mlnavabout"><a href="../../../about.html">about</a></div>
   <div class="mlnavitem" name="mlnavdoc"><a href="../../../docs.html">docs</a></div>
   <div class="mlnavitem" name="mlnavhelp"><a href="../../../help.html">get help</a></div>
   <div class="mlnavitem" name="mlnavbugs"><a href="https://github.com/mlpack/mlpack">github</a></div>
  </div>
</div>
</center>
<div class="separator"></div>
<center >
<div class="mainsection smallertext">
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody >
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>

<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul >
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a></li>  </ul>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmlpack_1_1tree_1_1ExampleTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::tree::ExampleTree&lt; MetricType, StatisticType, MatType &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">

<p >This is not an actual space tree but instead an example tree that exists to show and document all the functions that mlpack trees must implement.  
 <a href="classmlpack_1_1tree_1_1ExampleTree.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abaaf19b1a2b919d4e2d28bb90525ae91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#abaaf19b1a2b919d4e2d28bb90525ae91">ExampleTree</a> (const MatType &amp;dataset, MetricType &amp;<a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a4b4eb828f7492ebafa97a7991c04c315">metric</a>)</td></tr>
<tr class="memdesc:abaaf19b1a2b919d4e2d28bb90525ae91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor will build the tree given a dataset and an instantiated metric.  <a href="#abaaf19b1a2b919d4e2d28bb90525ae91">More...</a><br /></br></td></tr>
<tr class="separator:abaaf19b1a2b919d4e2d28bb90525ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d64dfc68f6e0dce7400f76d6f9f9bd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a9d64dfc68f6e0dce7400f76d6f9f9bd7">Centroid</a> (arma::vec &amp;centroid) const</td></tr>
<tr class="memdesc:a9d64dfc68f6e0dce7400f76d6f9f9bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the given vector with the center of the node.  <a href="#a9d64dfc68f6e0dce7400f76d6f9f9bd7">More...</a><br /></br></td></tr>
<tr class="separator:a9d64dfc68f6e0dce7400f76d6f9f9bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cf2fe8dfe8db5b677aac20e5388a66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a65cf2fe8dfe8db5b677aac20e5388a66">Child</a> (const size_t i) const</td></tr>
<tr class="memdesc:a65cf2fe8dfe8db5b677aac20e5388a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a particular child of this node.  <a href="#a65cf2fe8dfe8db5b677aac20e5388a66">More...</a><br /></br></td></tr>
<tr class="separator:a65cf2fe8dfe8db5b677aac20e5388a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44308fa6063a394e0bbf56970348313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#ab44308fa6063a394e0bbf56970348313">Child</a> (const size_t i)</td></tr>
<tr class="memdesc:ab44308fa6063a394e0bbf56970348313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a particular child of this node.  <a href="#ab44308fa6063a394e0bbf56970348313">More...</a><br /></br></td></tr>
<tr class="separator:ab44308fa6063a394e0bbf56970348313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6316f1f44e2f068df34024df74fe0f4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a6316f1f44e2f068df34024df74fe0f4f">Descendant</a> (const size_t i) const</td></tr>
<tr class="memdesc:a6316f1f44e2f068df34024df74fe0f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a particular descendant point.  <a href="#a6316f1f44e2f068df34024df74fe0f4f">More...</a><br /></br></td></tr>
<tr class="separator:a6316f1f44e2f068df34024df74fe0f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f24ea7ac68117c6f04d216d51d442b6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a3f24ea7ac68117c6f04d216d51d442b6">FurthestDescendantDistance</a> () const</td></tr>
<tr class="memdesc:a3f24ea7ac68117c6f04d216d51d442b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from the center of the node to the furthest descendant point of this node.  <a href="#a3f24ea7ac68117c6f04d216d51d442b6">More...</a><br /></br></td></tr>
<tr class="separator:a3f24ea7ac68117c6f04d216d51d442b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80eda5801429cc1dc55503067f5c3686"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a80eda5801429cc1dc55503067f5c3686">MaxDistance</a> (const MatType &amp;point) const</td></tr>
<tr class="memdesc:a80eda5801429cc1dc55503067f5c3686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance between this node and a point.  <a href="#a80eda5801429cc1dc55503067f5c3686">More...</a><br /></br></td></tr>
<tr class="separator:a80eda5801429cc1dc55503067f5c3686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c0cba31c5d9828f1377c3e5177cac5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a99c0cba31c5d9828f1377c3e5177cac5">MaxDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a99c0cba31c5d9828f1377c3e5177cac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance between this node and another node.  <a href="#a99c0cba31c5d9828f1377c3e5177cac5">More...</a><br /></br></td></tr>
<tr class="separator:a99c0cba31c5d9828f1377c3e5177cac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb033e47ef29032802487167603697f1"><td class="memItemLeft" align="right" valign="top">const MetricType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#acb033e47ef29032802487167603697f1">Metric</a> () const</td></tr>
<tr class="memdesc:acb033e47ef29032802487167603697f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instantiated metric for this node.  <a href="#acb033e47ef29032802487167603697f1">More...</a><br /></br></td></tr>
<tr class="separator:acb033e47ef29032802487167603697f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685237eef81085d8c7b140c71ec87776"><td class="memItemLeft" align="right" valign="top">MetricType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a685237eef81085d8c7b140c71ec87776">Metric</a> ()</td></tr>
<tr class="memdesc:a685237eef81085d8c7b140c71ec87776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the instantiated metric for this node.  <a href="#a685237eef81085d8c7b140c71ec87776">More...</a><br /></br></td></tr>
<tr class="separator:a685237eef81085d8c7b140c71ec87776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0db3f39e9bd9021a20cbab7fc4cce6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#aaf0db3f39e9bd9021a20cbab7fc4cce6">MinDistance</a> (const MatType &amp;point) const</td></tr>
<tr class="memdesc:aaf0db3f39e9bd9021a20cbab7fc4cce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance between this node and a point.  <a href="#aaf0db3f39e9bd9021a20cbab7fc4cce6">More...</a><br /></br></td></tr>
<tr class="separator:aaf0db3f39e9bd9021a20cbab7fc4cce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6963a7387cce7b172926c3a2f86ffea8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a6963a7387cce7b172926c3a2f86ffea8">MinDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a6963a7387cce7b172926c3a2f86ffea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance between this node and another node.  <a href="#a6963a7387cce7b172926c3a2f86ffea8">More...</a><br /></br></td></tr>
<tr class="separator:a6963a7387cce7b172926c3a2f86ffea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443ef57eb681f00e8e9bbeb03fa479ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a443ef57eb681f00e8e9bbeb03fa479ad">NumChildren</a> () const</td></tr>
<tr class="memdesc:a443ef57eb681f00e8e9bbeb03fa479ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of this node.  <a href="#a443ef57eb681f00e8e9bbeb03fa479ad">More...</a><br /></br></td></tr>
<tr class="separator:a443ef57eb681f00e8e9bbeb03fa479ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ecc7063998845b6f5108a1b68714fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a90ecc7063998845b6f5108a1b68714fb">NumDescendants</a> () const</td></tr>
<tr class="memdesc:a90ecc7063998845b6f5108a1b68714fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of descendant points.  <a href="#a90ecc7063998845b6f5108a1b68714fb">More...</a><br /></br></td></tr>
<tr class="separator:a90ecc7063998845b6f5108a1b68714fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b70a038873aa2b30fe4eb16f9a02a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#af6b70a038873aa2b30fe4eb16f9a02a6">NumPoints</a> () const</td></tr>
<tr class="memdesc:af6b70a038873aa2b30fe4eb16f9a02a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points held in this node.  <a href="#af6b70a038873aa2b30fe4eb16f9a02a6">More...</a><br /></br></td></tr>
<tr class="separator:af6b70a038873aa2b30fe4eb16f9a02a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae8ed8fcad87c0ce446b559e944c8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a5ae8ed8fcad87c0ce446b559e944c8ac">Parent</a> () const</td></tr>
<tr class="memdesc:a5ae8ed8fcad87c0ce446b559e944c8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parent node (NULL if this is the root of the tree).  <a href="#a5ae8ed8fcad87c0ce446b559e944c8ac">More...</a><br /></br></td></tr>
<tr class="separator:a5ae8ed8fcad87c0ce446b559e944c8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641fdfea3cd96ac14365933b80e47c65"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a641fdfea3cd96ac14365933b80e47c65">ParentDistance</a> () const</td></tr>
<tr class="memdesc:a641fdfea3cd96ac14365933b80e47c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from the center of this node to the center of the parent node.  <a href="#a641fdfea3cd96ac14365933b80e47c65">More...</a><br /></br></td></tr>
<tr class="separator:a641fdfea3cd96ac14365933b80e47c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa62499de20168b01a5c9bb3f0f4facd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#aaa62499de20168b01a5c9bb3f0f4facd">Point</a> (const size_t i) const</td></tr>
<tr class="memdesc:aaa62499de20168b01a5c9bb3f0f4facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of a particular point of this node.  <a href="#aaa62499de20168b01a5c9bb3f0f4facd">More...</a><br /></br></td></tr>
<tr class="separator:aaa62499de20168b01a5c9bb3f0f4facd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fde9f04650b762f2229f1ee661dccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1Range.html">math::Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a78fde9f04650b762f2229f1ee661dccb">RangeDistance</a> (const MatType &amp;point) const</td></tr>
<tr class="memdesc:a78fde9f04650b762f2229f1ee661dccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return both the minimum and maximum distances between this node and a point as a <a class="el" href="classmlpack_1_1math_1_1Range.html" title="Simple real-valued range. ">math::Range</a> object.  <a href="#a78fde9f04650b762f2229f1ee661dccb">More...</a><br /></br></td></tr>
<tr class="separator:a78fde9f04650b762f2229f1ee661dccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4216c1e4ac88737b47790c24f79d4fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1Range.html">math::Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#ab4216c1e4ac88737b47790c24f79d4fe">RangeDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> &amp;other) const</td></tr>
<tr class="memdesc:ab4216c1e4ac88737b47790c24f79d4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return both the minimum and maximum distances between this node and another node as a <a class="el" href="classmlpack_1_1math_1_1Range.html" title="Simple real-valued range. ">math::Range</a> object.  <a href="#ab4216c1e4ac88737b47790c24f79d4fe">More...</a><br /></br></td></tr>
<tr class="separator:ab4216c1e4ac88737b47790c24f79d4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97b099e48dd33d1a70d5de7790cc09"><td class="memItemLeft" align="right" valign="top">const StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a2c97b099e48dd33d1a70d5de7790cc09">Stat</a> () const</td></tr>
<tr class="memdesc:a2c97b099e48dd33d1a70d5de7790cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the statistic for this node.  <a href="#a2c97b099e48dd33d1a70d5de7790cc09">More...</a><br /></br></td></tr>
<tr class="separator:a2c97b099e48dd33d1a70d5de7790cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5d05dd720049d3580d425f62bdb27f"><td class="memItemLeft" align="right" valign="top">StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a2b5d05dd720049d3580d425f62bdb27f">Stat</a> ()</td></tr>
<tr class="memdesc:a2b5d05dd720049d3580d425f62bdb27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the statistic for this node.  <a href="#a2b5d05dd720049d3580d425f62bdb27f">More...</a><br /></br></td></tr>
<tr class="separator:a2b5d05dd720049d3580d425f62bdb27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4b4eb828f7492ebafa97a7991c04c315"><td class="memItemLeft" align="right" valign="top">MetricType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a4b4eb828f7492ebafa97a7991c04c315">metric</a></td></tr>
<tr class="memdesc:a4b4eb828f7492ebafa97a7991c04c315"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member is just here so the <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html" title="This is not an actual space tree but instead an example tree that exists to show and document all the...">ExampleTree</a> compiles without warnings.  <a href="#a4b4eb828f7492ebafa97a7991c04c315">More...</a><br /></br></td></tr>
<tr class="separator:a4b4eb828f7492ebafa97a7991c04c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eea6c74781112a993ed0ca8693e47b"><td class="memItemLeft" align="right" valign="top">StatisticType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a32eea6c74781112a993ed0ca8693e47b">stat</a></td></tr>
<tr class="memdesc:a32eea6c74781112a993ed0ca8693e47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member is just here so the <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html" title="This is not an actual space tree but instead an example tree that exists to show and document all the...">ExampleTree</a> compiles without warnings.  <a href="#a32eea6c74781112a993ed0ca8693e47b">More...</a><br /></br></td></tr>
<tr class="separator:a32eea6c74781112a993ed0ca8693e47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3 ><br />template&lt;typename MetricType = metric::LMetric&lt;2, true&gt;, typename StatisticType = EmptyStatistic, typename MatType = arma::mat&gt;</br>
class mlpack::tree::ExampleTree&lt; MetricType, StatisticType, MatType &gt;</h3>

<p >This is not an actual space tree but instead an example tree that exists to show and document all the functions that mlpack trees must implement. </p>
<p >For a better overview of trees, see <a class="el" href="trees.html">The TreeType policy in mlpack</a>. Also be aware that the implementations of each of the methods in this example tree are entirely fake and do not work; this example tree exists for its API, not its implementation.</p>
<p >Note that trees often have different properties. These properties are known at compile-time through the <a class="el" href="classmlpack_1_1tree_1_1TreeTraits.html" title="The TreeTraits class provides compile-time information on the characteristics of a given tree type...">mlpack::tree::TreeTraits</a> class, and some properties may imply the existence (or non-existence) of certain functions. Refer to the <a class="el" href="classmlpack_1_1tree_1_1TreeTraits.html" title="The TreeTraits class provides compile-time information on the characteristics of a given tree type...">TreeTraits</a> for more documentation on that.</p>
<p >The three template parameters below must be template parameters to the tree, in the order given below. More template parameters are fine, but they must come after the first three.</p>
<dl class="tparams"><dt >Template Parameters</dt><dd >
  <table class="tparams">
    <tr ><td class="paramname">MetricType</td><td >This defines the space in which the tree will be built. For some trees, arbitrary metrics cannot be used, and a template metaprogramming approach should be used to issue a compile-time error if a metric cannot be used with a specific tree type. One example is the <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree. ">tree::BinarySpaceTree</a> tree type, which cannot work with the <a class="el" href="classmlpack_1_1metric_1_1IPMetric.html" title="The inner product metric, IPMetric, takes a given Mercer kernel (KernelType), and when Evaluate() is ...">metric::IPMetric</a> class. </td></tr>
    <tr ><td class="paramname">StatisticType</td><td >A tree node can hold a statistic, which is sometimes useful for various dual-tree algorithms. The tree itself does not need to know anything about how the statistic works, but it needs to hold a StatisticType in each node. It can be assumed that the StatisticType class has a constructor StatisticType(const ExampleTree&amp;). </td></tr>
    <tr ><td class="paramname">MatType</td><td >A tree could be built on a dense matrix or a sparse matrix. All mlpack trees should be able to support any Armadillo-compatible matrix type. When the tree is written it should be assumed that MatType has the same functionality as arma::mat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="example__tree_8hpp_source.html#l00066">66</a> of file <a class="el" href="example__tree_8hpp_source.html">example_tree.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abaaf19b1a2b919d4e2d28bb90525ae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaf19b1a2b919d4e2d28bb90525ae91">&#9670;&nbsp;</a></span>ExampleTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a> </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >dataset</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">MetricType &amp;&#160;</td>
          <td class="paramname"><em >metric</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >This constructor will build the tree given a dataset and an instantiated metric. </p>
<p >Note that the parameter is a MatType&amp; and not an arma::mat&amp;. The dataset is not modified by the tree-building process (if it is, see the documentation for <a class="el" href="classmlpack_1_1tree_1_1TreeTraits.html#ae6207c6ccffcc6ff51e60f5edbe40d05" title="This is true if the tree rearranges points in the dataset when it is built. ">mlpack::tree::TreeTraits::RearrangesDataset</a> for how to deal with that situation). The MetricType parameter is necessary even though some metrics do not hold any state. This is so that the tree does not have to worry about instantiating the metric (if the tree had to worry about this, this would almost certainly incur additional runtime complexity and a larger runtime size of the tree node objects, which is to be avoided). The metric can't be const, in case MetricType::Evaluate() is non-const.</p>
<p >When this constructor is finished, the entire tree will be built and ready to use. The constructor should call the constructor of the statistic for each node that is built (see <a class="el" href="classmlpack_1_1tree_1_1EmptyStatistic.html" title="Empty statistic if you are not interested in storing statistics in your tree. ">tree::EmptyStatistic</a> for more information).</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">dataset</td><td >The dataset that the tree will be built on. </td></tr>
    <tr ><td class="paramname">metric</td><td >The instantiated metric to use to build the dataset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d64dfc68f6e0dce7400f76d6f9f9bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d64dfc68f6e0dce7400f76d6f9f9bd7">&#9670;&nbsp;</a></span>Centroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Centroid </td>
          <td >(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em >centroid</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Fill the given vector with the center of the node. </p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">centroid</td><td >Vector to be filled with the center of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65cf2fe8dfe8db5b677aac20e5388a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cf2fe8dfe8db5b677aac20e5388a66">&#9670;&nbsp;</a></span>Child() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Child </td>
          <td >(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em >i</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return a particular child of this node. </p>

</div>
</div>
<a id="ab44308fa6063a394e0bbf56970348313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44308fa6063a394e0bbf56970348313">&#9670;&nbsp;</a></span>Child() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Child </td>
          <td >(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em >i</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Modify a particular child of this node. </p>

</div>
</div>
<a id="a6316f1f44e2f068df34024df74fe0f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6316f1f44e2f068df34024df74fe0f4f">&#9670;&nbsp;</a></span>Descendant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Descendant </td>
          <td >(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em >i</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Get the index of a particular descendant point. </p>
<p >The ordering of the descendants does not matter, as long as calling Descendant(0) through Descendant(<a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a90ecc7063998845b6f5108a1b68714fb" title="Get the number of descendant points. ">NumDescendants()</a> - 1) will return the indices of every unique descendant point of the node. </p>

</div>
</div>
<a id="a3f24ea7ac68117c6f04d216d51d442b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f24ea7ac68117c6f04d216d51d442b6">&#9670;&nbsp;</a></span>FurthestDescendantDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">double <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::FurthestDescendantDistance </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Get the distance from the center of the node to the furthest descendant point of this node. </p>
<p >This does not necessarily need to be the exact furthest descendant distance but instead can be an upper bound. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information. </p>

</div>
</div>
<a id="a80eda5801429cc1dc55503067f5c3686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80eda5801429cc1dc55503067f5c3686">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">double <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::MaxDistance </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >point</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the maximum distance between this node and a point. </p>
<p >It is not required that the exact maximum distance between the node and the point is returned but instead an upper bound on the maximum distance will suffice. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">point</td><td >Point to return [upper bound on] maximum distance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99c0cba31c5d9828f1377c3e5177cac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c0cba31c5d9828f1377c3e5177cac5">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">double <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::MaxDistance </td>
          <td >(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the maximum distance between this node and another node. </p>
<p >It is not required that the exact maximum distance between the two nodes be returned but instead an upper bound on the maximum distance will suffice. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">node</td><td >Node to return [upper bound on] maximum distance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb033e47ef29032802487167603697f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb033e47ef29032802487167603697f1">&#9670;&nbsp;</a></span>Metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">const MetricType&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Metric </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Get the instantiated metric for this node. </p>

</div>
</div>
<a id="a685237eef81085d8c7b140c71ec87776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685237eef81085d8c7b140c71ec87776">&#9670;&nbsp;</a></span>Metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">MetricType&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Metric </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Modify the instantiated metric for this node. </p>

</div>
</div>
<a id="aaf0db3f39e9bd9021a20cbab7fc4cce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0db3f39e9bd9021a20cbab7fc4cce6">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">double <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::MinDistance </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >point</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the minimum distance between this node and a point. </p>
<p >It is not required that the exact minimum distance between the node and the point is returned but instead a lower bound on the minimum distance will suffice. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">point</td><td >Point to return [lower bound on] minimum distance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6963a7387cce7b172926c3a2f86ffea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6963a7387cce7b172926c3a2f86ffea8">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">double <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::MinDistance </td>
          <td >(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the minimum distance between this node and another node. </p>
<p >It is not required that the exact minimum distance between the two nodes be returned but instead a lower bound on the minimum distance will suffice. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">node</td><td >Node to return [lower bound on] minimum distance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a443ef57eb681f00e8e9bbeb03fa479ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443ef57eb681f00e8e9bbeb03fa479ad">&#9670;&nbsp;</a></span>NumChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::NumChildren </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the number of children of this node. </p>

</div>
</div>
<a id="a90ecc7063998845b6f5108a1b68714fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ecc7063998845b6f5108a1b68714fb">&#9670;&nbsp;</a></span>NumDescendants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::NumDescendants </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Get the number of descendant points. </p>
<p >This is the number of unique points held in this node plus the number of points held in all descendant nodes. This could be calculated at build-time and cached, or could be calculated at run-time. This may be harder to calculate for trees that may hold points in multiple nodes (like cover trees and spill trees, for instance). </p>

</div>
</div>
<a id="af6b70a038873aa2b30fe4eb16f9a02a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b70a038873aa2b30fe4eb16f9a02a6">&#9670;&nbsp;</a></span>NumPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::NumPoints </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the number of points held in this node. </p>

</div>
</div>
<a id="a5ae8ed8fcad87c0ce446b559e944c8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae8ed8fcad87c0ce446b559e944c8ac">&#9670;&nbsp;</a></span>Parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a>* <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Parent </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the parent node (NULL if this is the root of the tree). </p>

</div>
</div>
<a id="a641fdfea3cd96ac14365933b80e47c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641fdfea3cd96ac14365933b80e47c65">&#9670;&nbsp;</a></span>ParentDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">double <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::ParentDistance </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Get the distance from the center of this node to the center of the parent node. </p>

</div>
</div>
<a id="aaa62499de20168b01a5c9bb3f0f4facd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa62499de20168b01a5c9bb3f0f4facd">&#9670;&nbsp;</a></span>Point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Point </td>
          <td >(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em >i</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return the index of a particular point of this node. </p>
<p >mlpack trees do not, in general, hold the actual dataset, and instead just hold the indices of the points they contain. Thus, you might use this function in code like this:</p>
<div class="fragment"><div class="line">arma::vec thirdPoint = dataset.col(treeNode.Point(2));</div></div> 
</div>
</div>
<a id="a78fde9f04650b762f2229f1ee661dccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fde9f04650b762f2229f1ee661dccb">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1Range.html">math::Range</a> <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::RangeDistance </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >point</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return both the minimum and maximum distances between this node and a point as a <a class="el" href="classmlpack_1_1math_1_1Range.html" title="Simple real-valued range. ">math::Range</a> object. </p>
<p >This overload is given because it is possible that, for some tree types, calculation of both at once is faster than a call to <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#aaf0db3f39e9bd9021a20cbab7fc4cce6" title="Return the minimum distance between this node and a point. ">MinDistance()</a> then <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a80eda5801429cc1dc55503067f5c3686" title="Return the maximum distance between this node and a point. ">MaxDistance()</a>. It is not necessary that the minimum and maximum distances be exact; it is sufficient to return a lower bound on the minimum distance and an upper bound on the maximum distance. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">point</td><td >Point to return [bounds on] minimum and maximum distances to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4216c1e4ac88737b47790c24f79d4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4216c1e4ac88737b47790c24f79d4fe">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1Range.html">math::Range</a> <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::RangeDistance </td>
          <td >(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Return both the minimum and maximum distances between this node and another node as a <a class="el" href="classmlpack_1_1math_1_1Range.html" title="Simple real-valued range. ">math::Range</a> object. </p>
<p >This overload is given because it is possible that, for some tree types, calculation of both at once is faster than a call to <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#aaf0db3f39e9bd9021a20cbab7fc4cce6" title="Return the minimum distance between this node and a point. ">MinDistance()</a> then <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html#a80eda5801429cc1dc55503067f5c3686" title="Return the maximum distance between this node and a point. ">MaxDistance()</a>. It is not necessary that the minimum and maximum distances be exact; it is sufficient to return a lower bound on the minimum distance and an upper bound on the maximum distance. See the definitions in <a class="el" href="trees.html">The TreeType policy in mlpack</a> for more information.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">node</td><td >Node to return [bounds on] minimum and maximum distances to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c97b099e48dd33d1a70d5de7790cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c97b099e48dd33d1a70d5de7790cc09">&#9670;&nbsp;</a></span>Stat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">const StatisticType&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Stat </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Get the statistic for this node. </p>

</div>
</div>
<a id="a2b5d05dd720049d3580d425f62bdb27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5d05dd720049d3580d425f62bdb27f">&#9670;&nbsp;</a></span>Stat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr >
          <td class="memname">StatisticType&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::Stat </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Modify the statistic for this node. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4b4eb828f7492ebafa97a7991c04c315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4eb828f7492ebafa97a7991c04c315">&#9670;&nbsp;</a></span>metric</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">MetricType&amp; <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >This member is just here so the <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html" title="This is not an actual space tree but instead an example tree that exists to show and document all the...">ExampleTree</a> compiles without warnings. </p>
<p >It is not required to be a member in every type of tree. Be aware that storing the metric as a member and not a reference may mean that for some metrics (such as <a class="el" href="classmlpack_1_1metric_1_1MahalanobisDistance.html" title="The Mahalanobis distance, which is essentially a stretched Euclidean distance. ">metric::MahalanobisDistance</a> in high dimensionality) may incur lots of unnecessary matrix copying. </p>

<p class="definition">Definition at line <a class="el" href="example__tree_8hpp_source.html#l00244">244</a> of file <a class="el" href="example__tree_8hpp_source.html">example_tree.hpp</a>.</p>

</div>
</div>
<a id="a32eea6c74781112a993ed0ca8693e47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eea6c74781112a993ed0ca8693e47b">&#9670;&nbsp;</a></span>stat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::LMetric&lt;2, true&gt;, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">StatisticType <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html">mlpack::tree::ExampleTree</a>&lt; MetricType, StatisticType, MatType &gt;::stat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >This member is just here so the <a class="el" href="classmlpack_1_1tree_1_1ExampleTree.html" title="This is not an actual space tree but instead an example tree that exists to show and document all the...">ExampleTree</a> compiles without warnings. </p>
<p >It is not required to be a member in every type of tree. </p>

<p class="definition">Definition at line <a class="el" href="example__tree_8hpp_source.html#l00235">235</a> of file <a class="el" href="example__tree_8hpp_source.html">example_tree.hpp</a>.</p>

</div>
</div>
<hr ></hr>The documentation for this class was generated from the following file:<ul >
<li >src/mlpack/core/tree/<a class="el" href="example__tree_8hpp_source.html">example_tree.hpp</a></li>
</ul>
</div>

<hr class="footer"></hr><address class="footer"><small >
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"></img>
</a> 1.8.13
</small></address>
</div>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>