<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mlpack: mlpack::data Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">2.0.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1data.html">data</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::data Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to load and save matrices and models.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html">DatasetInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dimension.  <a href="classmlpack_1_1data_1_1DatasetInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A first shim for arrays.  <a href="structmlpack_1_1data_1_1FirstArrayShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A first shim for arrays without a Serialize() method.  <a href="structmlpack_1_1data_1_1FirstNormalArrayShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first shim: simply holds the object and its name.  <a href="structmlpack_1_1data_1_1FirstShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1HasSerializeFunction.html">HasSerializeFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1PointerShim.html">PointerShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shim for pointers.  <a href="structmlpack_1_1data_1_1PointerShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1SecondArrayShim.html">SecondArrayShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shim for objects in an array; this is basically like the <a class="el" href="structmlpack_1_1data_1_1SecondShim.html" title="The second shim: wrap the call to Serialize() inside of a serialize() function, so that an archive ty...">SecondShim</a>, but for arrays that hold objects that have Serialize() methods instead of <a class="el" href="structmlpack_1_1data_1_1SecondArrayShim.html#a9b7f34ee88e73a99ced7ca803c6c010d" title="A wrapper for Serialize() for each element. ">serialize()</a> methods.  <a href="structmlpack_1_1data_1_1SecondArrayShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1SecondNormalArrayShim.html">SecondNormalArrayShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shim for objects in an array which do not have a Serialize() function.  <a href="structmlpack_1_1data_1_1SecondNormalArrayShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1data_1_1SecondShim.html">SecondShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The second shim: wrap the call to Serialize() inside of a <a class="el" href="structmlpack_1_1data_1_1SecondShim.html#af876ca6368e66bbfebbfa8ca25ad3b45" title="A wrapper for t.Serialize(). ">serialize()</a> function, so that an archive type can call <a class="el" href="structmlpack_1_1data_1_1SecondShim.html#af876ca6368e66bbfebbfa8ca25ad3b45" title="A wrapper for t.Serialize(). ">serialize()</a> on a <a class="el" href="structmlpack_1_1data_1_1SecondShim.html" title="The second shim: wrap the call to Serialize() inside of a serialize() function, so that an archive ty...">SecondShim</a> object and this gets forwarded correctly to our object's Serialize() function.  <a href="structmlpack_1_1data_1_1SecondShim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a32e8cde4498e5ed79dae4f9d1a845058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a32e8cde4498e5ed79dae4f9d1a845058">Datatype</a> : bool { <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a32e8cde4498e5ed79dae4f9d1a845058a49e7dca1d58e49381fcafd2fa8befe40">numeric</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a32e8cde4498e5ed79dae4f9d1a845058afa48efb7194c09e640a4946fcb133190">categorical</a> = 1
<br />
 }<tr class="memdesc:a32e8cde4498e5ed79dae4f9d1a845058"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Datatype enum specifies the types of data mlpack algorithms can use.  <a href="namespacemlpack_1_1data.html#a32e8cde4498e5ed79dae4f9d1a845058">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a32e8cde4498e5ed79dae4f9d1a845058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fdad40c0f211749dd5b7794a478ad7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">format</a> { <br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7a7b886036a0428eed2491c5bbf9193850">autodetect</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7a33fb1046da125412af0ac83904b1f559">text</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7ac63d17a4db61541233d7579e571c6274">xml</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7a00d3edb681e6bb8301dd7ede06c12dbd">binary</a>
<br />
 }<tr class="memdesc:a82fdad40c0f211749dd5b7794a478ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the formats we can read through <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a>.  <a href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a82fdad40c0f211749dd5b7794a478ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb9f148330dd6ed69f9450ad24ee03e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb9f148330dd6ed69f9450ad24ee03e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#acb9f148330dd6ed69f9450ad24ee03e3">CreateArrayNVP</a> (T *t, const size_t len, const std::string &amp;name, typename boost::enable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *=0)</td></tr>
<tr class="memdesc:acb9f148330dd6ed69f9450ad24ee03e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to produce a name-value pair for an array; this is similar to boost::serialization::make_array(), but provides a nicer wrapper, allows types that have a Serialize() function, and allows you to give a name to your array.  <a href="#acb9f148330dd6ed69f9450ad24ee03e3">More...</a><br /></td></tr>
<tr class="separator:acb9f148330dd6ed69f9450ad24ee03e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd81c141c45051c1a32206f93fa461"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42cd81c141c45051c1a32206f93fa461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a42cd81c141c45051c1a32206f93fa461">CreateArrayNVP</a> (T *t, const size_t len, const std::string &amp;name, typename boost::disable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *=0)</td></tr>
<tr class="memdesc:a42cd81c141c45051c1a32206f93fa461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to produce a name-value pair for an array; this is similar to boost::serialization::make_array(), but provides a nicer wrapper, allows types that have a Serialize() function, and allows you to give a name to your array.  <a href="#a42cd81c141c45051c1a32206f93fa461">More...</a><br /></td></tr>
<tr class="separator:a42cd81c141c45051c1a32206f93fa461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeda624bdd47a8387cc8fb25772e7567"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afeda624bdd47a8387cc8fb25772e7567"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#afeda624bdd47a8387cc8fb25772e7567">CreateNVP</a> (T &amp;t, const std::string &amp;name, typename boost::enable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *=0)</td></tr>
<tr class="memdesc:afeda624bdd47a8387cc8fb25772e7567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function.  <a href="#afeda624bdd47a8387cc8fb25772e7567">More...</a><br /></td></tr>
<tr class="separator:afeda624bdd47a8387cc8fb25772e7567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0ffa9cd579cd25fb3c64cf80f99174"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c0ffa9cd579cd25fb3c64cf80f99174"><td class="memTemplItemLeft" align="right" valign="top">const boost::serialization::nvp&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a7c0ffa9cd579cd25fb3c64cf80f99174">CreateNVP</a> (T &amp;t, const std::string &amp;name, typename boost::disable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *=0, typename boost::disable_if&lt; boost::is_pointer&lt; T &gt;&gt;::type *=0)</td></tr>
<tr class="memdesc:a7c0ffa9cd579cd25fb3c64cf80f99174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function.  <a href="#a7c0ffa9cd579cd25fb3c64cf80f99174">More...</a><br /></td></tr>
<tr class="separator:a7c0ffa9cd579cd25fb3c64cf80f99174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739c59f26a56d6440b8b8a7e65347fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1739c59f26a56d6440b8b8a7e65347fa"><td class="memTemplItemLeft" align="right" valign="top">const boost::serialization::nvp&lt; <a class="el" href="structmlpack_1_1data_1_1PointerShim.html">PointerShim</a>&lt; T &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a1739c59f26a56d6440b8b8a7e65347fa">CreateNVP</a> (T *&amp;t, const std::string &amp;name, typename boost::enable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *=0)</td></tr>
<tr class="memdesc:a1739c59f26a56d6440b8b8a7e65347fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function.  <a href="#a1739c59f26a56d6440b8b8a7e65347fa">More...</a><br /></td></tr>
<tr class="separator:a1739c59f26a56d6440b8b8a7e65347fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2842a4909221431b690f882808c7e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e2842a4909221431b690f882808c7e8"><td class="memTemplItemLeft" align="right" valign="top">const boost::serialization::nvp&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a4e2842a4909221431b690f882808c7e8">CreateNVP</a> (T *&amp;t, const std::string &amp;name, typename boost::disable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *=0)</td></tr>
<tr class="memdesc:a4e2842a4909221431b690f882808c7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function.  <a href="#a4e2842a4909221431b690f882808c7e8">More...</a><br /></td></tr>
<tr class="separator:a4e2842a4909221431b690f882808c7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a13b28050a64b446916c067e1466951"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a5a13b28050a64b446916c067e1466951">Extension</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a5a13b28050a64b446916c067e1466951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab6ed8ea2bbfe83ccc5554bc9dd6dee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a0ab6ed8ea2bbfe83ccc5554bc9dd6dee">HAS_MEM_FUNC</a> (Serialize, HasSerializeCheck)</td></tr>
<tr class="separator:a0ab6ed8ea2bbfe83ccc5554bc9dd6dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19805d6585ac8b0be7c4e4b7f081977c"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a19805d6585ac8b0be7c4e4b7f081977c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a19805d6585ac8b0be7c4e4b7f081977c">Load</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, const bool fatal=false, const bool transpose=true)</td></tr>
<tr class="memdesc:a19805d6585ac8b0be7c4e4b7f081977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix from file, guessing the filetype from the extension.  <a href="#a19805d6585ac8b0be7c4e4b7f081977c">More...</a><br /></td></tr>
<tr class="separator:a19805d6585ac8b0be7c4e4b7f081977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cd401ac166a40e1e836f752814402b"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:ae8cd401ac166a40e1e836f752814402b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ae8cd401ac166a40e1e836f752814402b">Load</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html">DatasetInfo</a> &amp;info, const bool fatal=false, const bool transpose=true)</td></tr>
<tr class="memdesc:ae8cd401ac166a40e1e836f752814402b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object.  <a href="#ae8cd401ac166a40e1e836f752814402b">More...</a><br /></td></tr>
<tr class="separator:ae8cd401ac166a40e1e836f752814402b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#ac0441d5f7e76f0fcdeec487d4a9732ac">Load</a> (const std::string &amp;filename, const std::string &amp;name, T &amp;t, const bool fatal=false, <a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">format</a> f=format::autodetect)</td></tr>
<tr class="memdesc:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a model from a file, guessing the filetype from the extension, or, optionally, loading the specified format.  <a href="#ac0441d5f7e76f0fcdeec487d4a9732ac">More...</a><br /></td></tr>
<tr class="separator:ac0441d5f7e76f0fcdeec487d4a9732ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a7dc1fd86524b8dd245bb91841731"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a951a7dc1fd86524b8dd245bb91841731"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a951a7dc1fd86524b8dd245bb91841731">LoadARFF</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a951a7dc1fd86524b8dd245bb91841731"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix without any modification).  <a href="#a951a7dc1fd86524b8dd245bb91841731">More...</a><br /></td></tr>
<tr class="separator:a951a7dc1fd86524b8dd245bb91841731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1be4cad3ce3ac3b1d033e99354f3eb1"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:af1be4cad3ce3ac3b1d033e99354f3eb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#af1be4cad3ce3ac3b1d033e99354f3eb1">LoadARFF</a> (const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html">DatasetInfo</a> &amp;info)</td></tr>
<tr class="memdesc:af1be4cad3ce3ac3b1d033e99354f3eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to load an ARFF dataset as numeric and categorical features, using the <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> structure for mapping.  <a href="#af1be4cad3ce3ac3b1d033e99354f3eb1">More...</a><br /></td></tr>
<tr class="separator:af1be4cad3ce3ac3b1d033e99354f3eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b3fa5243889e2aed47ee750f840ed"><td class="memTemplParams" colspan="2">template&lt;typename eT , typename RowType &gt; </td></tr>
<tr class="memitem:a664b3fa5243889e2aed47ee750f840ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a664b3fa5243889e2aed47ee750f840ed">NormalizeLabels</a> (const RowType &amp;labelsIn, arma::Row&lt; size_t &gt; &amp;labels, arma::Col&lt; eT &gt; &amp;mapping)</td></tr>
<tr class="memdesc:a664b3fa5243889e2aed47ee750f840ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels.  <a href="#a664b3fa5243889e2aed47ee750f840ed">More...</a><br /></td></tr>
<tr class="separator:a664b3fa5243889e2aed47ee750f840ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1999a24345a08307e99a444b235e8d"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a2a1999a24345a08307e99a444b235e8d"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a2a1999a24345a08307e99a444b235e8d">operator&amp;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:a2a1999a24345a08307e99a444b235e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&amp; with a <a class="el" href="structmlpack_1_1data_1_1FirstShim.html" title="The first shim: simply holds the object and its name. ">FirstShim</a> object.  <a href="#a2a1999a24345a08307e99a444b235e8d">More...</a><br /></td></tr>
<tr class="separator:a2a1999a24345a08307e99a444b235e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f87a31d0723ccb95450df33839df40a"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a0f87a31d0723ccb95450df33839df40a"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a0f87a31d0723ccb95450df33839df40a">operator&amp;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:a0f87a31d0723ccb95450df33839df40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&amp; with a <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html" title="A first shim for arrays. ">FirstArrayShim</a> object.  <a href="#a0f87a31d0723ccb95450df33839df40a">More...</a><br /></td></tr>
<tr class="separator:a0f87a31d0723ccb95450df33839df40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b496b2fbfbf01f958934cc986dd49f"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a71b496b2fbfbf01f958934cc986dd49f"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a71b496b2fbfbf01f958934cc986dd49f">operator&amp;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:a71b496b2fbfbf01f958934cc986dd49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&amp; with a <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html" title="A first shim for arrays without a Serialize() method. ">FirstNormalArrayShim</a> object.  <a href="#a71b496b2fbfbf01f958934cc986dd49f">More...</a><br /></td></tr>
<tr class="separator:a71b496b2fbfbf01f958934cc986dd49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee30f774383a3233e70717ce62c777fe"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:aee30f774383a3233e70717ce62c777fe"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#aee30f774383a3233e70717ce62c777fe">operator&lt;&lt;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:aee30f774383a3233e70717ce62c777fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&lt;&lt; with a <a class="el" href="structmlpack_1_1data_1_1FirstShim.html" title="The first shim: simply holds the object and its name. ">FirstShim</a> object.  <a href="#aee30f774383a3233e70717ce62c777fe">More...</a><br /></td></tr>
<tr class="separator:aee30f774383a3233e70717ce62c777fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4ec6eec10c20876621eb1d3b54fa4e"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:afe4ec6eec10c20876621eb1d3b54fa4e"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#afe4ec6eec10c20876621eb1d3b54fa4e">operator&lt;&lt;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:afe4ec6eec10c20876621eb1d3b54fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&lt;&lt; with a <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html" title="A first shim for arrays. ">FirstArrayShim</a> object.  <a href="#afe4ec6eec10c20876621eb1d3b54fa4e">More...</a><br /></td></tr>
<tr class="separator:afe4ec6eec10c20876621eb1d3b54fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383ab28ecde36144fcd76b205aae0579"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a383ab28ecde36144fcd76b205aae0579"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a383ab28ecde36144fcd76b205aae0579">operator&lt;&lt;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:a383ab28ecde36144fcd76b205aae0579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&lt;&lt; with a <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html" title="A first shim for arrays without a Serialize() method. ">FirstNormalArrayShim</a> object.  <a href="#a383ab28ecde36144fcd76b205aae0579">More...</a><br /></td></tr>
<tr class="separator:a383ab28ecde36144fcd76b205aae0579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2e91fe48953177282f96a961046586"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:acb2e91fe48953177282f96a961046586"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#acb2e91fe48953177282f96a961046586">operator&gt;&gt;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:acb2e91fe48953177282f96a961046586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&gt;&gt; with a <a class="el" href="structmlpack_1_1data_1_1FirstShim.html" title="The first shim: simply holds the object and its name. ">FirstShim</a> object.  <a href="#acb2e91fe48953177282f96a961046586">More...</a><br /></td></tr>
<tr class="separator:acb2e91fe48953177282f96a961046586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519b0fa49757cd56804b5a3da923f6d9"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a519b0fa49757cd56804b5a3da923f6d9"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a519b0fa49757cd56804b5a3da923f6d9">operator&gt;&gt;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:a519b0fa49757cd56804b5a3da923f6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&gt;&gt; with a <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html" title="A first shim for arrays. ">FirstArrayShim</a> object.  <a href="#a519b0fa49757cd56804b5a3da923f6d9">More...</a><br /></td></tr>
<tr class="separator:a519b0fa49757cd56804b5a3da923f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106773eaf403d022d3cd59915a1e2c8b"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a106773eaf403d022d3cd59915a1e2c8b"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a106773eaf403d022d3cd59915a1e2c8b">operator&gt;&gt;</a> (Archive &amp;ar, <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt; t)</td></tr>
<tr class="memdesc:a106773eaf403d022d3cd59915a1e2c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catch when we call operator&gt;&gt; with a <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html" title="A first shim for arrays without a Serialize() method. ">FirstNormalArrayShim</a> object.  <a href="#a106773eaf403d022d3cd59915a1e2c8b">More...</a><br /></td></tr>
<tr class="separator:a106773eaf403d022d3cd59915a1e2c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901fe08dcdc58734f64a864dbdef0a28"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a901fe08dcdc58734f64a864dbdef0a28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a901fe08dcdc58734f64a864dbdef0a28">RevertLabels</a> (const arma::Row&lt; size_t &gt; &amp;labels, const arma::Col&lt; eT &gt; &amp;mapping, arma::Row&lt; eT &gt; &amp;labelsOut)</td></tr>
<tr class="memdesc:a901fe08dcdc58734f64a864dbdef0a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the 'mapping' vector.  <a href="#a901fe08dcdc58734f64a864dbdef0a28">More...</a><br /></td></tr>
<tr class="separator:a901fe08dcdc58734f64a864dbdef0a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bc794b14db0ab126595b19a32a5bc0"><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr class="memitem:a16bc794b14db0ab126595b19a32a5bc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a16bc794b14db0ab126595b19a32a5bc0">Save</a> (const std::string &amp;filename, const arma::Mat&lt; eT &gt; &amp;matrix, const bool fatal=false, bool transpose=true)</td></tr>
<tr class="memdesc:a16bc794b14db0ab126595b19a32a5bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a matrix to file, guessing the filetype from the extension.  <a href="#a16bc794b14db0ab126595b19a32a5bc0">More...</a><br /></td></tr>
<tr class="separator:a16bc794b14db0ab126595b19a32a5bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30f8bfca9b924d6d935c9f1fae91778"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af30f8bfca9b924d6d935c9f1fae91778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#af30f8bfca9b924d6d935c9f1fae91778">Save</a> (const std::string &amp;filename, const std::string &amp;name, T &amp;t, const bool fatal=false, <a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">format</a> f=format::autodetect)</td></tr>
<tr class="memdesc:af30f8bfca9b924d6d935c9f1fae91778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format.  <a href="#af30f8bfca9b924d6d935c9f1fae91778">More...</a><br /></td></tr>
<tr class="separator:af30f8bfca9b924d6d935c9f1fae91778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900bb36af4ef0fff3351bb3adb09b8c5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a900bb36af4ef0fff3351bb3adb09b8c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a900bb36af4ef0fff3351bb3adb09b8c5">Split</a> (const arma::Mat&lt; T &gt; &amp;input, const arma::Row&lt; U &gt; &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, arma::Row&lt; U &gt; &amp;trainLabel, arma::Row&lt; U &gt; &amp;testLabel, const double testRatio)</td></tr>
<tr class="memdesc:a900bb36af4ef0fff3351bb3adb09b8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, split into a training set and test set.  <a href="#a900bb36af4ef0fff3351bb3adb09b8c5">More...</a><br /></td></tr>
<tr class="separator:a900bb36af4ef0fff3351bb3adb09b8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2045f699140a37ef0c6f0b3ef816c854"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2045f699140a37ef0c6f0b3ef816c854"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a2045f699140a37ef0c6f0b3ef816c854">Split</a> (const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, const double testRatio)</td></tr>
<tr class="memdesc:a2045f699140a37ef0c6f0b3ef816c854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset, split into a training set and test set.  <a href="#a2045f699140a37ef0c6f0b3ef816c854">More...</a><br /></td></tr>
<tr class="separator:a2045f699140a37ef0c6f0b3ef816c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813771e519dd63fd2f2b886d976826ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a813771e519dd63fd2f2b886d976826ce"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; arma::Mat&lt; T &gt;, arma::Mat&lt; T &gt;, arma::Row&lt; U &gt;, arma::Row&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a813771e519dd63fd2f2b886d976826ce">Split</a> (const arma::Mat&lt; T &gt; &amp;input, const arma::Row&lt; U &gt; &amp;inputLabel, const double testRatio)</td></tr>
<tr class="memdesc:a813771e519dd63fd2f2b886d976826ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset and labels, split into a training set and test set.  <a href="#a813771e519dd63fd2f2b886d976826ce">More...</a><br /></td></tr>
<tr class="separator:a813771e519dd63fd2f2b886d976826ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fb8838c66ff6351af3bbb33ee6ebe1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80fb8838c66ff6351af3bbb33ee6ebe1"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; arma::Mat&lt; T &gt;, arma::Mat&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlpack_1_1data.html#a80fb8838c66ff6351af3bbb33ee6ebe1">Split</a> (const arma::Mat&lt; T &gt; &amp;input, const double testRatio)</td></tr>
<tr class="memdesc:a80fb8838c66ff6351af3bbb33ee6ebe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input dataset, split into a training set and test set.  <a href="#a80fb8838c66ff6351af3bbb33ee6ebe1">More...</a><br /></td></tr>
<tr class="separator:a80fb8838c66ff6351af3bbb33ee6ebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to load and save matrices and models. </p>
<p>Functions to load and save matrices.</p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a32e8cde4498e5ed79dae4f9d1a845058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlpack_1_1data.html#a32e8cde4498e5ed79dae4f9d1a845058">mlpack::data::Datatype</a> : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Datatype enum specifies the types of data mlpack algorithms can use. </p>
<p>The vast majority of mlpack algorithms can only use numeric data (i.e. float/double/etc.), but some algorithms can use categorical data, specified via this Datatype enum and the <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a32e8cde4498e5ed79dae4f9d1a845058a49e7dca1d58e49381fcafd2fa8befe40"></a>numeric&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a32e8cde4498e5ed79dae4f9d1a845058afa48efb7194c09e640a4946fcb133190"></a>categorical&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="dataset__info_8hpp_source.html#l00032">32</a> of file <a class="el" href="dataset__info_8hpp_source.html">dataset_info.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82fdad40c0f211749dd5b7794a478ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">mlpack::data::format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the formats we can read through <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a82fdad40c0f211749dd5b7794a478ad7a7b886036a0428eed2491c5bbf9193850"></a>autodetect&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a82fdad40c0f211749dd5b7794a478ad7a33fb1046da125412af0ac83904b1f559"></a>text&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a82fdad40c0f211749dd5b7794a478ad7ac63d17a4db61541233d7579e571c6274"></a>xml&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a82fdad40c0f211749dd5b7794a478ad7a00d3edb681e6bb8301dd7ede06c12dbd"></a>binary&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="format_8hpp_source.html#l00022">22</a> of file <a class="el" href="format_8hpp_source.html">format.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acb9f148330dd6ed69f9450ad24ee03e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt;T&gt; mlpack::data::CreateArrayNVP </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::enable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to produce a name-value pair for an array; this is similar to boost::serialization::make_array(), but provides a nicer wrapper, allows types that have a Serialize() function, and allows you to give a name to your array. </p>
<p>This particular overload is used by classes that have a Serialize() function. </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00215">215</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42cd81c141c45051c1a32206f93fa461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt;T&gt; mlpack::data::CreateArrayNVP </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::disable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to produce a name-value pair for an array; this is similar to boost::serialization::make_array(), but provides a nicer wrapper, allows types that have a Serialize() function, and allows you to give a name to your array. </p>
<p>This particular overload is used by classes that do not have a Serialize() function or primitive types. </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00232">232</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afeda624bdd47a8387cc8fb25772e7567"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt;T&gt; mlpack::data::CreateNVP </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::enable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function. </p>
<p>The template type should be automatically deduced, and the two boost::enable_if&lt;&gt; parameters are automatically deduced too. So usage looks like</p>
<div class="fragment"><div class="line">MyType t;</div><div class="line"><a class="code" href="namespacemlpack_1_1data.html#afeda624bdd47a8387cc8fb25772e7567">CreateNVP</a>(t, <span class="stringliteral">&quot;my_name_for_t&quot;</span>);</div></div><!-- fragment --><p>Note that the second parameter, 'name', must be a valid XML identifier.</p>
<p>This function does not return a boost::serialization::nvp&lt;T&gt; object, but instead a shim type (FirstShim&lt;T&gt;).</p>
<p>This particular overload is used by classes that have a Serialize() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Object to create NVP (name-value pair) with. </td></tr>
    <tr><td class="paramname">name</td><td>Name of object (must be a valid XML identifier). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00095">95</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>Referenced by <a class="el" href="binary__numeric__split__info_8hpp_source.html#l00039">mlpack::tree::BinaryNumericSplitInfo&lt; ObservationType &gt;::Serialize()</a>, <a class="el" href="numeric__split__info_8hpp_source.html#l00043">mlpack::tree::NumericSplitInfo&lt; ObservationType &gt;::Serialize()</a>, <a class="el" href="range__search__stat_8hpp_source.html#l00051">mlpack::range::RangeSearchStat::Serialize()</a>, <a class="el" href="regression__distribution_8hpp_source.html#l00067">mlpack::distribution::RegressionDistribution::Serialize()</a>, <a class="el" href="ra__query__stat_8hpp_source.html#l00067">mlpack::neighbor::RAQueryStat&lt; SortPolicy &gt;::Serialize()</a>, <a class="el" href="polynomial__kernel_8hpp_source.html#l00074">mlpack::kernel::PolynomialKernel::Serialize()</a>, <a class="el" href="hyperbolic__tangent__kernel_8hpp_source.html#l00079">mlpack::kernel::HyperbolicTangentKernel::Serialize()</a>, <a class="el" href="x__tree__split_8hpp_source.html#l00080">mlpack::tree::XTreeSplit&lt; TreeType &gt;::SplitHistoryStruct::Serialize()</a>, <a class="el" href="eigenvalue__ratio__constraint_8hpp_source.html#l00083">mlpack::gmm::EigenvalueRatioConstraint::Serialize()</a>, <a class="el" href="triangular__kernel_8hpp_source.html#l00092">mlpack::kernel::TriangularKernel::Serialize()</a>, <a class="el" href="refined__start_8hpp_source.html#l00094">mlpack::kmeans::RefinedStart::Serialize()</a>, <a class="el" href="neighbor__search__stat_8hpp_source.html#l00097">mlpack::neighbor::NeighborSearchStat&lt; neighbor::NearestNeighborSort &gt;::Serialize()</a>, <a class="el" href="dataset__info_8hpp_source.html#l00099">mlpack::data::DatasetInfo::Serialize()</a>, <a class="el" href="laplacian__kernel_8hpp_source.html#l00103">mlpack::kernel::LaplacianKernel::Serialize()</a>, <a class="el" href="fastmks__stat_8hpp_source.html#l00105">mlpack::fastmks::FastMKSStat::Serialize()</a>, <a class="el" href="spherical__kernel_8hpp_source.html#l00111">mlpack::kernel::SphericalKernel::Serialize()</a>, <a class="el" href="hoeffding__categorical__split_8hpp_source.html#l00113">mlpack::tree::HoeffdingCategoricalSplit&lt; FitnessFunction &gt;::Serialize()</a>, <a class="el" href="linear__regression_8hpp_source.html#l00122">mlpack::regression::LinearRegression::Serialize()</a>, <a class="el" href="laplace__distribution_8hpp_source.html#l00149">mlpack::distribution::LaplaceDistribution::Serialize()</a>, <a class="el" href="gaussian__distribution_8hpp_source.html#l00151">mlpack::distribution::GaussianDistribution::Serialize()</a>, <a class="el" href="gaussian__kernel_8hpp_source.html#l00151">mlpack::kernel::GaussianKernel::Serialize()</a>, <a class="el" href="discrete__distribution_8hpp_source.html#l00167">mlpack::distribution::DiscreteDistribution::Serialize()</a>, <a class="el" href="svd__batch__learning_8hpp_source.html#l00171">mlpack::amf::SVDBatchLearning::Serialize()</a>, <a class="el" href="softmax__regression_8hpp_source.html#l00181">mlpack::regression::SoftmaxRegression&lt; OptimizerType &gt;::Serialize()</a>, <a class="el" href="dtree_8hpp_source.html#l00292">mlpack::det::DTree::Serialize()</a>, <a class="el" href="serialization__shim_8hpp_source.html#l00324">mlpack::data::SecondArrayShim&lt; T &gt;::serialize()</a>, <a class="el" href="serialization_8hpp_source.html#l00174">mlpack::SerializeObject()</a>, and <a class="el" href="serialization_8hpp_source.html#l00222">mlpack::SerializePointerObject()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c0ffa9cd579cd25fb3c64cf80f99174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::serialization::nvp&lt;T&gt; mlpack::data::CreateNVP </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::disable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::disable_if&lt; boost::is_pointer&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function. </p>
<p>The template type should be automatically deduced, and the two boost::enable_if&lt;&gt; parameters are automatically deduced too. So usage looks like</p>
<div class="fragment"><div class="line">MyType t;</div><div class="line"><a class="code" href="namespacemlpack_1_1data.html#afeda624bdd47a8387cc8fb25772e7567">CreateNVP</a>(t, <span class="stringliteral">&quot;my_name_for_t&quot;</span>);</div></div><!-- fragment --><p>Note that the second parameter, 'name', must be a valid XML identifier.</p>
<p>This particular overload is used by classes that do not have a Serialize() function (so, no shim is necessary) or primitive types that aren't pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Object to create NVP (name-value pair) with. </td></tr>
    <tr><td class="paramname">name</td><td>Name of object (must be a valid XML identifier). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00129">129</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1739c59f26a56d6440b8b8a7e65347fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::serialization::nvp&lt;<a class="el" href="structmlpack_1_1data_1_1PointerShim.html">PointerShim</a>&lt;T&gt;*&gt; mlpack::data::CreateNVP </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::enable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function. </p>
<p>The template type should be automatically deduced, and the two boost::enable_if&lt;&gt; parameters are automatically deduced too. So usage looks like</p>
<div class="fragment"><div class="line">MyType t;</div><div class="line"><a class="code" href="namespacemlpack_1_1data.html#afeda624bdd47a8387cc8fb25772e7567">CreateNVP</a>(t, <span class="stringliteral">&quot;my_name_for_t&quot;</span>);</div></div><!-- fragment --><p>Note that the second parameter, 'name', must be a valid XML identifier.</p>
<p>This particular overload is used by pointers to classes that have a Serialize() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Object to create NVP (name-value pair) with. </td></tr>
    <tr><td class="paramname">name</td><td>Name of object (must be a valid XML identifier). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00164">164</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e2842a4909221431b690f882808c7e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::serialization::nvp&lt;T*&gt; mlpack::data::CreateNVP </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::disable_if&lt; <a class="el" href="structmlpack_1_1data_1_1HasSerialize.html">HasSerialize</a>&lt; T &gt;&gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to produce a name-value pair; this is similar to BOOST_SERIALIZATION_NVP(), but should be used for types that have a Serialize() function (or contain a type that has a Serialize() function) instead of a <a class="el" href="namespaceboost_1_1serialization.html#a5c7f0e288c18c6887ba037b2bef6230d" title="Catch a call to serialize() with a PointerShim, and call the Serialize() function directly...">serialize()</a> function. </p>
<p>The template type should be automatically deduced, and the two boost::enable_if&lt;&gt; parameters are automatically deduced too. So usage looks like</p>
<div class="fragment"><div class="line">MyType t;</div><div class="line"><a class="code" href="namespacemlpack_1_1data.html#afeda624bdd47a8387cc8fb25772e7567">CreateNVP</a>(t, <span class="stringliteral">&quot;my_name_for_t&quot;</span>);</div></div><!-- fragment --><p>Note that the second parameter, 'name', must be a valid XML identifier.</p>
<p>This particular overload is used by pointers to classes that do not have a Serialize() function, or pointers to non-classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Object to create NVP (name-value pair) with. </td></tr>
    <tr><td class="paramname">name</td><td>Name of object (must be a valid XML identifier). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00199">199</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a13b28050a64b446916c067e1466951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlpack::data::Extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="extension_8hpp_source.html#l00023">23</a> of file <a class="el" href="extension_8hpp_source.html">extension.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ab6ed8ea2bbfe83ccc5554bc9dd6dee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlpack::data::HAS_MEM_FUNC </td>
          <td>(</td>
          <td class="paramtype">Serialize&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HasSerializeCheck&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19805d6585ac8b0be7c4e4b7f081977c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix from file, guessing the filetype from the extension. </p>
<p>This will transpose the matrix at load time (unless the transpose parameter is set to false). If the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>CSV (csv_ascii), denoted by .csv, or optionally .txt</li>
<li>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</li>
<li>ASCII (raw_ascii), denoted by .txt</li>
<li>Armadillo ASCII (arma_ascii), also denoted by .txt</li>
<li>PGM (pgm_binary), denoted by .pgm</li>
<li>PPM (ppm_binary), denoted by .ppm</li>
<li>Raw binary (raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma_binary), denoted by .bin</li>
<li>HDF5, denoted by .hdf, .hdf5, .h5, or .he5</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo's default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter 'transpose' controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load contents of file into. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix after loading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8cd401ac166a40e1e836f752814402b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html">DatasetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object. </p>
<p>This will transpose the matrix (unless the transpose parameter is set to false). This particular overload of <a class="el" href="namespacemlpack_1_1data.html#a19805d6585ac8b0be7c4e4b7f081977c" title="Loads a matrix from file, guessing the filetype from the extension. ">Load()</a> can only load text-based formats, such as those given below:</p>
<ul>
<li>CSV (csv_ascii), denoted by .csv, or optionally .txt</li>
<li>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</li>
<li>ASCII (raw_ascii), denoted by .txt</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo's default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</p>
<p>If the parameter 'fatal' is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter 'transpose' controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of 'true'.</p>
<p>The <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object passed to this function will be re-created, so any mappings from previous loads will be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load contents of file into. </td></tr>
    <tr><td class="paramname">info</td><td><a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object to populate with mappings and data types. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix after loading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of load. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0441d5f7e76f0fcdeec487d4a9732ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">format</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code>format::autodetect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a model from a file, guessing the filetype from the extension, or, optionally, loading the specified format. </p>
<p>If automatic extension detection is used and the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as what is supported by the <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a> library:</p>
<ul>
<li>text, denoted by .txt</li>
<li>xml, denoted by .xml</li>
<li>binary, denoted by .bin</li>
</ul>
<p>The format parameter can take any of the values in the 'format' enum: 'format::autodetect', 'format::text', 'format::xml', and 'format::binary'. The autodetect functionality operates on the file extension (so, "file.txt" would be autodetected as text).</p>
<p>The name parameter should be specified to indicate the name of the structure to be loaded. This should be the same as the name that was used to save the structure (otherwise, the loading procedure will fail).</p>
<p>If the parameter 'fatal' is set to true, then an exception will be thrown in the event of load failure. Otherwise, the method will return false and the relevant error information will be printed to <a class="el" href="classmlpack_1_1Log.html#abbf3c5ac36654c0a8f17be3549388b38" title="Prints warning messages prefixed with [WARN ]. ">Log::Warn</a>. </p>

</div>
</div>
<a class="anchor" id="a951a7dc1fd86524b8dd245bb91841731"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::LoadARFF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix without any modification). </p>
<p>An exception will be thrown if any features are non-numeric. </p>

</div>
</div>
<a class="anchor" id="af1be4cad3ce3ac3b1d033e99354f3eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::LoadARFF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html">DatasetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to load an ARFF dataset as numeric and categorical features, using the <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> structure for mapping. </p>
<p>An exception will be thrown upon failure.</p>
<p>A pre-existing <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object can be passed in, but if the dimensionality of the given <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object (info.Dimensionality()) does not match the dimensionality of the data, a std::invalid_argument exception will be thrown. If an empty <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object is given (constructed with the default constructor or otherwise, so that info.Dimensionality() is 0), it will be set to the right dimensionality.</p>
<p>This ability to pass in pre-existing <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> objects is very necessary when, e.g., loading a test set after training. If the same <a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> from loading the training set is not used, then the test set may be loaded with different mappings&mdash;which can cause horrible problems!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of ARFF file to load. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to load data into. </td></tr>
    <tr><td class="paramname">info</td><td><a class="el" href="classmlpack_1_1data_1_1DatasetInfo.html" title="Auxiliary information for a dataset, including mappings to/from strings and the datatype of each dime...">DatasetInfo</a> object; can be default-constructed or pre-existing from another call to <a class="el" href="namespacemlpack_1_1data.html#a951a7dc1fd86524b8dd245bb91841731" title="A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix witho...">LoadARFF()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a664b3fa5243889e2aed47ee750f840ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT , typename RowType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::NormalizeLabels </td>
          <td>(</td>
          <td class="paramtype">const RowType &amp;&#160;</td>
          <td class="paramname"><em>labelsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels. </p>
<p>Also, a reverse mapping from the new label to the old value is stored in the 'mapping' vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelsIn</td><td>Input labels of arbitrary datatype. </td></tr>
    <tr><td class="paramname">labels</td><td>Vector that unsigned labels will be stored in. </td></tr>
    <tr><td class="paramname">mapping</td><td>Reverse mapping to convert new labels back to old labels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a1999a24345a08307e99a444b235e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&amp; with a <a class="el" href="structmlpack_1_1data_1_1FirstShim.html" title="The first shim: simply holds the object and its name. ">FirstShim</a> object. </p>
<p>In this case, we make the second-level shim and use it. Note that this second-level shim can be used as an lvalue, which is what's necessary for this whole thing to work. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00386">386</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>References <a class="el" href="serialization__shim_8hpp_source.html#l00253">mlpack::data::FirstShim&lt; T &gt;::name</a>, and <a class="el" href="serialization__shim_8hpp_source.html#l00252">mlpack::data::FirstShim&lt; T &gt;::t</a>.</p>

<p>Referenced by <a class="el" href="hrectbound_8hpp_source.html#l00104">mlpack::bound::HRectBound&lt; metric::EuclideanDistance, ElemType &gt;::MinWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f87a31d0723ccb95450df33839df40a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&amp; with a <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html" title="A first shim for arrays. ">FirstArrayShim</a> object. </p>
<p>In this case, we make the second-level array shim and use it. Note that this second-level shim can be used as an lvalue, which is what's necessary for this whole thing to work. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00428">428</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>References <a class="el" href="serialization__shim_8hpp_source.html#l00269">mlpack::data::FirstArrayShim&lt; T &gt;::len</a>, <a class="el" href="serialization__shim_8hpp_source.html#l00270">mlpack::data::FirstArrayShim&lt; T &gt;::name</a>, and <a class="el" href="serialization__shim_8hpp_source.html#l00268">mlpack::data::FirstArrayShim&lt; T &gt;::t</a>.</p>

</div>
</div>
<a class="anchor" id="a71b496b2fbfbf01f958934cc986dd49f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&amp; with a <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html" title="A first shim for arrays without a Serialize() method. ">FirstNormalArrayShim</a> object. </p>
<p>In this case, we make the second-level array shim and use it. Note that this second-level shim can be used as an lvalue, which is necessary if we want to use make_nvp() safely. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00470">470</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>References <a class="el" href="serialization__shim_8hpp_source.html#l00286">mlpack::data::FirstNormalArrayShim&lt; T &gt;::len</a>, <a class="el" href="serialization__shim_8hpp_source.html#l00287">mlpack::data::FirstNormalArrayShim&lt; T &gt;::name</a>, and <a class="el" href="serialization__shim_8hpp_source.html#l00285">mlpack::data::FirstNormalArrayShim&lt; T &gt;::t</a>.</p>

</div>
</div>
<a class="anchor" id="aee30f774383a3233e70717ce62c777fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&lt;&lt; with a <a class="el" href="structmlpack_1_1data_1_1FirstShim.html" title="The first shim: simply holds the object and its name. ">FirstShim</a> object. </p>
<p>In this case, we make the second-level shim and use it. Note that this second-level shim can be used as an lvalue, which is what's necessary for this whole thing to work. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00372">372</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe4ec6eec10c20876621eb1d3b54fa4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&lt;&lt; with a <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html" title="A first shim for arrays. ">FirstArrayShim</a> object. </p>
<p>In this case, we make the second-level array shim and use it. Note that this second-level shim can be used as an lvalue, which is what's necessary for this whole thing to work. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00414">414</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a383ab28ecde36144fcd76b205aae0579"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&lt;&lt; with a <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html" title="A first shim for arrays without a Serialize() method. ">FirstNormalArrayShim</a> object. </p>
<p>In this case, we make the second-level array shim and use it. Note that this second-level shim can be used as an lvalue, which is necessary if we want to use make_nvp() safely. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00456">456</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb2e91fe48953177282f96a961046586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstShim.html">FirstShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&gt;&gt; with a <a class="el" href="structmlpack_1_1data_1_1FirstShim.html" title="The first shim: simply holds the object and its name. ">FirstShim</a> object. </p>
<p>In this case, we make the second-level shim and use it. Note that this second-level shim can be used as an lvalue, which is what's necessary for this whole thing to work. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00400">400</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>References <a class="el" href="serialization__shim_8hpp_source.html#l00253">mlpack::data::FirstShim&lt; T &gt;::name</a>, and <a class="el" href="serialization__shim_8hpp_source.html#l00252">mlpack::data::FirstShim&lt; T &gt;::t</a>.</p>

</div>
</div>
<a class="anchor" id="a519b0fa49757cd56804b5a3da923f6d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html">FirstArrayShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&gt;&gt; with a <a class="el" href="structmlpack_1_1data_1_1FirstArrayShim.html" title="A first shim for arrays. ">FirstArrayShim</a> object. </p>
<p>In this case, we make the second-level array shim and use it. Note that this second-level shim can be used as an lvalue, which is what's necessary for this whole thing to work. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00442">442</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>References <a class="el" href="serialization__shim_8hpp_source.html#l00269">mlpack::data::FirstArrayShim&lt; T &gt;::len</a>, <a class="el" href="serialization__shim_8hpp_source.html#l00270">mlpack::data::FirstArrayShim&lt; T &gt;::name</a>, and <a class="el" href="serialization__shim_8hpp_source.html#l00268">mlpack::data::FirstArrayShim&lt; T &gt;::t</a>.</p>

</div>
</div>
<a class="anchor" id="a106773eaf403d022d3cd59915a1e2c8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Archive&amp; mlpack::data::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html">FirstNormalArrayShim</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catch when we call operator&gt;&gt; with a <a class="el" href="structmlpack_1_1data_1_1FirstNormalArrayShim.html" title="A first shim for arrays without a Serialize() method. ">FirstNormalArrayShim</a> object. </p>
<p>In this case, we make the second-level array shim and use it. Note that this second-level shim can be used as an lvalue, which is necessary if we want to use make_nvp() safely. The first-level shim can't be an lvalue (this is why we need two levels of shims). </p>

<p>Definition at line <a class="el" href="serialization__shim_8hpp_source.html#l00484">484</a> of file <a class="el" href="serialization__shim_8hpp_source.html">serialization_shim.hpp</a>.</p>

<p>References <a class="el" href="serialization__shim_8hpp_source.html#l00286">mlpack::data::FirstNormalArrayShim&lt; T &gt;::len</a>, <a class="el" href="serialization__shim_8hpp_source.html#l00287">mlpack::data::FirstNormalArrayShim&lt; T &gt;::name</a>, and <a class="el" href="serialization__shim_8hpp_source.html#l00285">mlpack::data::FirstNormalArrayShim&lt; T &gt;::t</a>.</p>

</div>
</div>
<a class="anchor" id="a901fe08dcdc58734f64a864dbdef0a28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::RevertLabels </td>
          <td>(</td>
          <td class="paramtype">const arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Col&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>labelsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the 'mapping' vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labels</td><td>Set of normalized labels to convert. </td></tr>
    <tr><td class="paramname">mapping</td><td>Mapping to use to convert labels. </td></tr>
    <tr><td class="paramname">labelsOut</td><td>Vector to store new labels in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16bc794b14db0ab126595b19a32a5bc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Mat&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a matrix to file, guessing the filetype from the extension. </p>
<p>This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.</p>
<p>The supported types of files are the same as found in Armadillo:</p>
<ul>
<li>CSV (csv_ascii), denoted by .csv, or optionally .txt</li>
<li>ASCII (raw_ascii), denoted by .txt</li>
<li>Armadillo ASCII (arma_ascii), also denoted by .txt</li>
<li>PGM (pgm_binary), denoted by .pgm</li>
<li>PPM (ppm_binary), denoted by .ppm</li>
<li>Raw binary (raw_binary), denoted by .bin</li>
<li>Armadillo binary (arma_binary), denoted by .bin</li>
<li>HDF5 (hdf5_binary), denoted by .hdf5, .hdf, .h5, or .he5</li>
</ul>
<p>If the file extension is not one of those types, an error will be given. If the 'fatal' parameter is set to true, a std::runtime_error exception will be thrown upon failure. If the 'transpose' parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-major format and most datasets are stored on disk as row-major, this parameter should be left at its default value of 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file to save to. </td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to save into file. </td></tr>
    <tr><td class="paramname">fatal</td><td>If an error should be reported as fatal (default false). </td></tr>
    <tr><td class="paramname">transpose</td><td>If true, transpose the matrix before saving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating success or failure of save. </dd></dl>

</div>
</div>
<a class="anchor" id="af30f8bfca9b924d6d935c9f1fae91778"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlpack::data::Save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fatal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlpack_1_1data.html#a82fdad40c0f211749dd5b7794a478ad7">format</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code>format::autodetect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format. </p>
<p>If automatic extension detection is used and the filetype cannot be determined, and error will be given.</p>
<p>The supported types of files are the same as what is supported by the <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a> library:</p>
<ul>
<li>text, denoted by .txt</li>
<li>xml, denoted by .xml</li>
<li>binary, denoted by .bin</li>
</ul>
<p>The format parameter can take any of the values in the 'format' enum: 'format::autodetect', 'format::text', 'format::xml', and 'format::binary'. The autodetect functionality operates on the file extension (so, "file.txt" would be autodetected as text).</p>
<p>The name parameter should be specified to indicate the name of the structure to be saved. If <a class="el" href="namespacemlpack_1_1data.html#a19805d6585ac8b0be7c4e4b7f081977c" title="Loads a matrix from file, guessing the filetype from the extension. ">Load()</a> is later called on the generated file, the name used to load should be the same as the name used for this call to <a class="el" href="namespacemlpack_1_1data.html#a16bc794b14db0ab126595b19a32a5bc0" title="Saves a matrix to file, guessing the filetype from the extension. ">Save()</a>.</p>
<p>If the parameter 'fatal' is set to true, then an exception will be thrown in the event of a save failure. Otherwise, the method will return false and the relevant error information will be printed to <a class="el" href="classmlpack_1_1Log.html#abbf3c5ac36654c0a8f17be3549388b38" title="Prints warning messages prefixed with [WARN ]. ">Log::Warn</a>. </p>

</div>
</div>
<a class="anchor" id="a900bb36af4ef0fff3351bb3adb09b8c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Row&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>testLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, split into a training set and test set. </p>
<p>Example usage below. This overload places the split dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div><div class="line">arma::Row&lt;size_t&gt; label = loadLabel();</div><div class="line">arma::mat trainData;</div><div class="line">arma::mat testData;</div><div class="line">arma::Row&lt;size_t&gt; trainLabel;</div><div class="line">arma::Row&lt;size_t&gt; testLabel;</div><div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div><div class="line"></div><div class="line"><span class="comment">// Split the dataset into a training and test set, with 30% of the data being</span></div><div class="line"><span class="comment">// held out for the test set.</span></div><div class="line"><a class="code" href="namespacemlpack_1_1data.html#a900bb36af4ef0fff3351bb3adb09b8c5">Split</a>(input, label, trainData,</div><div class="line">               testData, trainLabel, testLabel, 0.3);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">label</td><td>Input labels to split. </td></tr>
    <tr><td class="paramname">trainData</td><td>Matrix to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>Matrix to store test data into. </td></tr>
    <tr><td class="paramname">trainLabel</td><td>Vector to store training labels into. </td></tr>
    <tr><td class="paramname">testLabel</td><td>Vector to store test labels into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="split__data_8hpp_source.html#l00051">51</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p>Referenced by <a class="el" href="split__data_8hpp_source.html#l00150">Split()</a>.</p>

</div>
</div>
<a class="anchor" id="a2045f699140a37ef0c6f0b3ef816c854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>trainData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>testData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset, split into a training set and test set. </p>
<p>Example usage below. This overload places the split dataset into the two output parameters given (trainData, testData).</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div><div class="line">arma::mat trainData;</div><div class="line">arma::mat testData;</div><div class="line"><a class="code" href="namespacemlpack_1_1math.html#a99560c3cf9c2db393309a31933b8d480">math::RandomSeed</a>(100); <span class="comment">// Set the seed if you like.</span></div><div class="line"></div><div class="line"><span class="comment">// Split the dataset into a training and test set, with 30% of the data being</span></div><div class="line"><span class="comment">// held out for the test set.</span></div><div class="line"><a class="code" href="namespacemlpack_1_1data.html#a900bb36af4ef0fff3351bb3adb09b8c5">Split</a>(input, trainData, testData, 0.3);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">trainData</td><td>Matrix to store training data into. </td></tr>
    <tr><td class="paramname">testData</td><td>Matrix to store test data into. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="split__data_8hpp_source.html#l00105">105</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a813771e519dd63fd2f2b886d976826ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;arma::Mat&lt;T&gt;, arma::Mat&lt;T&gt;, arma::Row&lt;U&gt;, arma::Row&lt;U&gt; &gt; mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Row&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset and labels, split into a training set and test set. </p>
<p>Example usage below. This overload returns the split dataset as a std::tuple with four elements: an arma::Mat&lt;T&gt; containing the training data, an arma::Mat&lt;T&gt; containing the test data, an arma::Row&lt;U&gt; containing the training labels, and an arma::Row&lt;U&gt; containing the test labels.</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div><div class="line">arma::Row&lt;size_t&gt; label = loadLabel();</div><div class="line"><span class="keyword">auto</span> splitResult = <a class="code" href="namespacemlpack_1_1data.html#a900bb36af4ef0fff3351bb3adb09b8c5">Split</a>(input, label, 0.2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">label</td><td>Input labels to split. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing trainData (arma::Mat&lt;T&gt;), testData (arma::Mat&lt;T&gt;), trainLabel (arma::Row&lt;U&gt;), and testLabel (arma::Row&lt;U&gt;). </dd></dl>

<p>Definition at line <a class="el" href="split__data_8hpp_source.html#l00150">150</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p>References <a class="el" href="split__data_8hpp_source.html#l00051">Split()</a>.</p>

</div>
</div>
<a class="anchor" id="a80fb8838c66ff6351af3bbb33ee6ebe1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;arma::Mat&lt;T&gt;, arma::Mat&lt;T&gt; &gt; mlpack::data::Split </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>testRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input dataset, split into a training set and test set. </p>
<p>Example usage below. This overload returns the split dataset as a std::tuple with two elements: an arma::Mat&lt;T&gt; containing the training data and an arma::Mat&lt;T&gt; containing the test data.</p>
<div class="fragment"><div class="line">arma::mat input = loadData();</div><div class="line"><span class="keyword">auto</span> splitResult = <a class="code" href="namespacemlpack_1_1data.html#a900bb36af4ef0fff3351bb3adb09b8c5">Split</a>(input, 0.2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input dataset to split. </td></tr>
    <tr><td class="paramname">testRatio</td><td>Percentage of dataset to use for test set (between 0 and 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing trainData (arma::Mat&lt;T&gt;) and testData (arma::Mat&lt;T&gt;). </dd></dl>

<p>Definition at line <a class="el" href="split__data_8hpp_source.html#l00186">186</a> of file <a class="el" href="split__data_8hpp_source.html">split_data.hpp</a>.</p>

<p>References <a class="el" href="split__data_8hpp_source.html#l00051">Split()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
