<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mlpack: mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">2.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1neighbor.html">neighbor</a></li><li class="navelem"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmlpack_1_1neighbor_1_1NeighborSearch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> class is a template class for performing distance-based neighbor searches.  
 <a href="classmlpack_1_1neighbor_1_1NeighborSearch.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3960fb4f9887fe8af0311808f0036819"><td class="memItemLeft" align="right" valign="top">typedef TreeType&lt; MetricType, <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchStat.html">NeighborSearchStat</a>&lt; SortPolicy &gt;, MatType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a></td></tr>
<tr class="memdesc:a3960fb4f9887fe8af0311808f0036819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef.  <a href="#a3960fb4f9887fe8af0311808f0036819">More...</a><br /></td></tr>
<tr class="separator:a3960fb4f9887fe8af0311808f0036819"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d96c045b02d692f548ea81f4d8f818e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3d96c045b02d692f548ea81f4d8f818e">NeighborSearch</a> (const MatType &amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a>, const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a> mode=<a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a>, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a3d96c045b02d692f548ea81f4d8f818e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, passing a reference dataset (this is the dataset which is searched).  <a href="#a3d96c045b02d692f548ea81f4d8f818e">More...</a><br /></td></tr>
<tr class="separator:a3d96c045b02d692f548ea81f4d8f818e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352315dc48e3cb5c8fc8ef8b0baec4b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a352315dc48e3cb5c8fc8ef8b0baec4b9">NeighborSearch</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a>, const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a> mode=<a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a>, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a352315dc48e3cb5c8fc8ef8b0baec4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, taking ownership of the reference dataset (this is the dataset which is searched).  <a href="#a352315dc48e3cb5c8fc8ef8b0baec4b9">More...</a><br /></td></tr>
<tr class="separator:a352315dc48e3cb5c8fc8ef8b0baec4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94774708c31c2b9c3f86135557224ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#af94774708c31c2b9c3f86135557224ce">NeighborSearch</a> (const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a>, const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a> mode=<a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a>, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:af94774708c31c2b9c3f86135557224ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object with a copy of the given pre-constructed reference tree (this is the tree built on the points that will be searched).  <a href="#af94774708c31c2b9c3f86135557224ce">More...</a><br /></td></tr>
<tr class="separator:af94774708c31c2b9c3f86135557224ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61596c37c527f077c651c3bf73cbb351"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a61596c37c527f077c651c3bf73cbb351">NeighborSearch</a> (<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a>, const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a> mode=<a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a>, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a61596c37c527f077c651c3bf73cbb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object with the given pre-constructed reference tree (this is the tree built on the points that will be searched).  <a href="#a61596c37c527f077c651c3bf73cbb351">More...</a><br /></td></tr>
<tr class="separator:a61596c37c527f077c651c3bf73cbb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c4a4e7f3f3f891d399eead8a1263f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#af6c4a4e7f3f3f891d399eead8a1263f8">NeighborSearch</a> (const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a> mode=<a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a>, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:af6c4a4e7f3f3f891d399eead8a1263f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object without any reference data.  <a href="#af6c4a4e7f3f3f891d399eead8a1263f8">More...</a><br /></td></tr>
<tr class="separator:af6c4a4e7f3f3f891d399eead8a1263f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd15ebef410145c5ca31f31fcfb0f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#abfd15ebef410145c5ca31f31fcfb0f3a">NeighborSearch</a> (const MatType &amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa391f6b077d648470c71e5fd10bd1c77">naive</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1784d84f3b870ccd44e21b6717b68626">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:abfd15ebef410145c5ca31f31fcfb0f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, passing a reference dataset (this is the dataset which is searched).  <a href="#abfd15ebef410145c5ca31f31fcfb0f3a">More...</a><br /></td></tr>
<tr class="separator:abfd15ebef410145c5ca31f31fcfb0f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92814d4bfcab403a41a94415c36070f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a92814d4bfcab403a41a94415c36070f1">NeighborSearch</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa391f6b077d648470c71e5fd10bd1c77">naive</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1784d84f3b870ccd44e21b6717b68626">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a92814d4bfcab403a41a94415c36070f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, taking ownership of the reference dataset (this is the dataset which is searched).  <a href="#a92814d4bfcab403a41a94415c36070f1">More...</a><br /></td></tr>
<tr class="separator:a92814d4bfcab403a41a94415c36070f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad157bab47d2b27e127611d7fb79249e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ad157bab47d2b27e127611d7fb79249e0">NeighborSearch</a> (<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1784d84f3b870ccd44e21b6717b68626">singleMode</a>, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:ad157bab47d2b27e127611d7fb79249e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object with the given pre-constructed reference tree (this is the tree built on the points that will be searched).  <a href="#ad157bab47d2b27e127611d7fb79249e0">More...</a><br /></td></tr>
<tr class="separator:ad157bab47d2b27e127611d7fb79249e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2b9e051ca9adfb74229cacd407b149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a2c2b9e051ca9adfb74229cacd407b149">NeighborSearch</a> (const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa391f6b077d648470c71e5fd10bd1c77">naive</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1784d84f3b870ccd44e21b6717b68626">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a>=0, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a2c2b9e051ca9adfb74229cacd407b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object without any reference data.  <a href="#a2c2b9e051ca9adfb74229cacd407b149">More...</a><br /></td></tr>
<tr class="separator:a2c2b9e051ca9adfb74229cacd407b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30023a0e353a6a304f18b3aed1f30a55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a30023a0e353a6a304f18b3aed1f30a55">~NeighborSearch</a> ()</td></tr>
<tr class="memdesc:a30023a0e353a6a304f18b3aed1f30a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object.  <a href="#a30023a0e353a6a304f18b3aed1f30a55">More...</a><br /></td></tr>
<tr class="separator:a30023a0e353a6a304f18b3aed1f30a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2d3c5e13b408fec3341e209504cc8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a33b2d3c5e13b408fec3341e209504cc8">BaseCases</a> () const </td></tr>
<tr class="memdesc:a33b2d3c5e13b408fec3341e209504cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of base case evaluations performed during the last search.  <a href="#a33b2d3c5e13b408fec3341e209504cc8">More...</a><br /></td></tr>
<tr class="separator:a33b2d3c5e13b408fec3341e209504cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64caddda792ac15e85bfc1c1a1995163"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a64caddda792ac15e85bfc1c1a1995163">Epsilon</a> () const </td></tr>
<tr class="memdesc:a64caddda792ac15e85bfc1c1a1995163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the relative error to be considered in approximate search.  <a href="#a64caddda792ac15e85bfc1c1a1995163">More...</a><br /></td></tr>
<tr class="separator:a64caddda792ac15e85bfc1c1a1995163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56b2db591a2b76ab27dbc0227d1bfbd"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae56b2db591a2b76ab27dbc0227d1bfbd">Epsilon</a> ()</td></tr>
<tr class="memdesc:ae56b2db591a2b76ab27dbc0227d1bfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the relative error to be considered in approximate search.  <a href="#ae56b2db591a2b76ab27dbc0227d1bfbd">More...</a><br /></td></tr>
<tr class="separator:ae56b2db591a2b76ab27dbc0227d1bfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef7176ab3505a027964a6300b850f64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a9ef7176ab3505a027964a6300b850f64">Greedy</a> () const </td></tr>
<tr class="memdesc:a9ef7176ab3505a027964a6300b850f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access whether or not search is done in greedy mode.  <a href="#a9ef7176ab3505a027964a6300b850f64">More...</a><br /></td></tr>
<tr class="separator:a9ef7176ab3505a027964a6300b850f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac753548b72a735b04b076dc8c4f2b97d"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac753548b72a735b04b076dc8c4f2b97d">Greedy</a> ()</td></tr>
<tr class="memdesc:ac753548b72a735b04b076dc8c4f2b97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not search is done in greedy mode.  <a href="#ac753548b72a735b04b076dc8c4f2b97d">More...</a><br /></td></tr>
<tr class="separator:ac753548b72a735b04b076dc8c4f2b97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59851ea78f9623623023d2cc154efd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac59851ea78f9623623023d2cc154efd9">Naive</a> () const </td></tr>
<tr class="memdesc:ac59851ea78f9623623023d2cc154efd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access whether or not search is done in naive linear scan mode.  <a href="#ac59851ea78f9623623023d2cc154efd9">More...</a><br /></td></tr>
<tr class="separator:ac59851ea78f9623623023d2cc154efd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d147bcd51799ae958d167bc351a5ab"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac9d147bcd51799ae958d167bc351a5ab">Naive</a> ()</td></tr>
<tr class="memdesc:ac9d147bcd51799ae958d167bc351a5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not search is done in naive linear scan mode.  <a href="#ac9d147bcd51799ae958d167bc351a5ab">More...</a><br /></td></tr>
<tr class="separator:ac9d147bcd51799ae958d167bc351a5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6661389e9e9fdd662d36f347bc15945d"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a6661389e9e9fdd662d36f347bc15945d">ReferenceSet</a> () const </td></tr>
<tr class="memdesc:a6661389e9e9fdd662d36f347bc15945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the reference dataset.  <a href="#a6661389e9e9fdd662d36f347bc15945d">More...</a><br /></td></tr>
<tr class="separator:a6661389e9e9fdd662d36f347bc15945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c87b9c41801e25320f418e21872c1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a94c87b9c41801e25320f418e21872c1e">ReferenceTree</a> () const </td></tr>
<tr class="memdesc:a94c87b9c41801e25320f418e21872c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the reference tree.  <a href="#a94c87b9c41801e25320f418e21872c1e">More...</a><br /></td></tr>
<tr class="separator:a94c87b9c41801e25320f418e21872c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8c3a20b9051e7f21b88bd7005317a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aea8c3a20b9051e7f21b88bd7005317a3">ReferenceTree</a> ()</td></tr>
<tr class="memdesc:aea8c3a20b9051e7f21b88bd7005317a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the reference tree.  <a href="#aea8c3a20b9051e7f21b88bd7005317a3">More...</a><br /></td></tr>
<tr class="separator:aea8c3a20b9051e7f21b88bd7005317a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e18ff5e39676f0128916b72859d9f3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a0e18ff5e39676f0128916b72859d9f3f">Scores</a> () const </td></tr>
<tr class="memdesc:a0e18ff5e39676f0128916b72859d9f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of node combination scores during the last search.  <a href="#a0e18ff5e39676f0128916b72859d9f3f">More...</a><br /></td></tr>
<tr class="separator:a0e18ff5e39676f0128916b72859d9f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e2a58f4d4d93e43ffa5c26e5ac298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298">Search</a> (const MatType &amp;querySet, const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances)</td></tr>
<tr class="memdesc:aa38e2a58f4d4d93e43ffa5c26e5ac298"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each point in the query set, compute the nearest neighbors and store the output in the given matrices.  <a href="#aa38e2a58f4d4d93e43ffa5c26e5ac298">More...</a><br /></td></tr>
<tr class="separator:aa38e2a58f4d4d93e43ffa5c26e5ac298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef823486a7fa2c583286212b5a0575f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a2ef823486a7fa2c583286212b5a0575f">Search</a> (<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *queryTree, const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances, bool sameSet=false)</td></tr>
<tr class="memdesc:a2ef823486a7fa2c583286212b5a0575f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pre-built query tree, search for the nearest neighbors of each point in the query tree, storing the output in the given matrices.  <a href="#a2ef823486a7fa2c583286212b5a0575f">More...</a><br /></td></tr>
<tr class="separator:a2ef823486a7fa2c583286212b5a0575f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c55603878488d69374f8475f11ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aab8c55603878488d69374f8475f11ce8">Search</a> (<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;queryTree, const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances, bool sameSet=false)</td></tr>
<tr class="memdesc:aab8c55603878488d69374f8475f11ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pre-built query tree, search for the nearest neighbors of each point in the query tree, storing the output in the given matrices.  <a href="#aab8c55603878488d69374f8475f11ce8">More...</a><br /></td></tr>
<tr class="separator:aab8c55603878488d69374f8475f11ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee72f753ad23efc31d16140b31481c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1ee72f753ad23efc31d16140b31481c1">Search</a> (const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances)</td></tr>
<tr class="memdesc:a1ee72f753ad23efc31d16140b31481c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the nearest neighbors of every point in the reference set.  <a href="#a1ee72f753ad23efc31d16140b31481c1">More...</a><br /></td></tr>
<tr class="separator:a1ee72f753ad23efc31d16140b31481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dcdd264303430172ec30ca4d313c53"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a86dcdd264303430172ec30ca4d313c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a86dcdd264303430172ec30ca4d313c53">Serialize</a> (Archive &amp;ar, const unsigned int)</td></tr>
<tr class="memdesc:a86dcdd264303430172ec30ca4d313c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> model.  <a href="#a86dcdd264303430172ec30ca4d313c53">More...</a><br /></td></tr>
<tr class="separator:a86dcdd264303430172ec30ca4d313c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24b18a10831919d8ddca5cec8663fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa24b18a10831919d8ddca5cec8663fb7">SingleMode</a> () const </td></tr>
<tr class="memdesc:aa24b18a10831919d8ddca5cec8663fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access whether or not search is done in single-tree mode.  <a href="#aa24b18a10831919d8ddca5cec8663fb7">More...</a><br /></td></tr>
<tr class="separator:aa24b18a10831919d8ddca5cec8663fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace3f909a89494c4c65110514f32662"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1ace3f909a89494c4c65110514f32662">SingleMode</a> ()</td></tr>
<tr class="memdesc:a1ace3f909a89494c4c65110514f32662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not search is done in single-tree mode.  <a href="#a1ace3f909a89494c4c65110514f32662">More...</a><br /></td></tr>
<tr class="separator:a1ace3f909a89494c4c65110514f32662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaef875683c28b8ef8089469757e819f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f">Train</a> (const MatType &amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a>)</td></tr>
<tr class="memdesc:afaef875683c28b8ef8089469757e819f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, and build a tree if necessary.  <a href="#afaef875683c28b8ef8089469757e819f">More...</a><br /></td></tr>
<tr class="separator:afaef875683c28b8ef8089469757e819f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574193c2e26ca71af167d7c932bf51ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a574193c2e26ca71af167d7c932bf51ef">Train</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a>)</td></tr>
<tr class="memdesc:a574193c2e26ca71af167d7c932bf51ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, taking ownership of the set, and build a tree if necessary.  <a href="#a574193c2e26ca71af167d7c932bf51ef">More...</a><br /></td></tr>
<tr class="separator:a574193c2e26ca71af167d7c932bf51ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8db16866104befd4b5f7636e031ba26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#af8db16866104befd4b5f7636e031ba26">Train</a> (<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a>)</td></tr>
<tr class="memdesc:af8db16866104befd4b5f7636e031ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference tree to a new reference tree.  <a href="#af8db16866104befd4b5f7636e031ba26">More...</a><br /></td></tr>
<tr class="separator:af8db16866104befd4b5f7636e031ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f82c7dd2450941d8dc75ab1113a9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a25f82c7dd2450941d8dc75ab1113a9af">Train</a> (const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a>)</td></tr>
<tr class="memdesc:a25f82c7dd2450941d8dc75ab1113a9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference tree as a copy of the given reference tree.  <a href="#a25f82c7dd2450941d8dc75ab1113a9af">More...</a><br /></td></tr>
<tr class="separator:a25f82c7dd2450941d8dc75ab1113a9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11324a983037f6e84526dfe709af5784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a11324a983037f6e84526dfe709af5784">Train</a> (<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a>)</td></tr>
<tr class="memdesc:a11324a983037f6e84526dfe709af5784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference tree to a new reference tree.  <a href="#a11324a983037f6e84526dfe709af5784">More...</a><br /></td></tr>
<tr class="separator:a11324a983037f6e84526dfe709af5784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaf5280eb5e6feaa304dd7bf77badef73"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aaf5280eb5e6feaa304dd7bf77badef73">EffectiveError</a> (arma::mat &amp;foundDistances, arma::mat &amp;realDistances)</td></tr>
<tr class="memdesc:aaf5280eb5e6feaa304dd7bf77badef73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the average relative error (effective error) between the distances calculated and the true distances provided.  <a href="#aaf5280eb5e6feaa304dd7bf77badef73">More...</a><br /></td></tr>
<tr class="separator:aaf5280eb5e6feaa304dd7bf77badef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c91e05636e7122400313270feca1d12"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a2c91e05636e7122400313270feca1d12">Recall</a> (arma::Mat&lt; size_t &gt; &amp;foundNeighbors, arma::Mat&lt; size_t &gt; &amp;realNeighbors)</td></tr>
<tr class="memdesc:a2c91e05636e7122400313270feca1d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the recall (% of neighbors found) given the list of found neighbors and the true set of neighbors.  <a href="#a2c91e05636e7122400313270feca1d12">More...</a><br /></td></tr>
<tr class="separator:a2c91e05636e7122400313270feca1d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab076be415133b12ba1417697563c9ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ab076be415133b12ba1417697563c9ff6">UpdateSearchMode</a> ()</td></tr>
<tr class="memdesc:ab076be415133b12ba1417697563c9ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates searchMode to be according to naive, singleMode and greedy booleans.  <a href="#ab076be415133b12ba1417697563c9ff6">More...</a><br /></td></tr>
<tr class="separator:ab076be415133b12ba1417697563c9ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b962adff1e42ca315ba38b67cbb08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a5f6b962adff1e42ca315ba38b67cbb08">UpdateSearchModeFlags</a> ()</td></tr>
<tr class="memdesc:a5f6b962adff1e42ca315ba38b67cbb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates naive, singleMode and greedy flags according to searchMode.  <a href="#a5f6b962adff1e42ca315ba38b67cbb08">More...</a><br /></td></tr>
<tr class="separator:a5f6b962adff1e42ca315ba38b67cbb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aee06866cee4bae43f4aaca591c5eb55c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aee06866cee4bae43f4aaca591c5eb55c">baseCases</a></td></tr>
<tr class="memdesc:aee06866cee4bae43f4aaca591c5eb55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of base cases.  <a href="#aee06866cee4bae43f4aaca591c5eb55c">More...</a><br /></td></tr>
<tr class="separator:aee06866cee4bae43f4aaca591c5eb55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d14564a86b37365a5aa6ff67d9f8f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a02d14564a86b37365a5aa6ff67d9f8f2">epsilon</a></td></tr>
<tr class="memdesc:a02d14564a86b37365a5aa6ff67d9f8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the relative error to be considered in approximate search.  <a href="#a02d14564a86b37365a5aa6ff67d9f8f2">More...</a><br /></td></tr>
<tr class="separator:a02d14564a86b37365a5aa6ff67d9f8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbcbe222f3ad8425f2a8045fc912e5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a9cbcbe222f3ad8425f2a8045fc912e5b">greedy</a></td></tr>
<tr class="memdesc:a9cbcbe222f3ad8425f2a8045fc912e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if greedy search is being used.  <a href="#a9cbcbe222f3ad8425f2a8045fc912e5b">More...</a><br /></td></tr>
<tr class="separator:a9cbcbe222f3ad8425f2a8045fc912e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68d8dd825fe1e2afe6ae76a3451f44a"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa68d8dd825fe1e2afe6ae76a3451f44a">metric</a></td></tr>
<tr class="memdesc:aa68d8dd825fe1e2afe6ae76a3451f44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiation of metric.  <a href="#aa68d8dd825fe1e2afe6ae76a3451f44a">More...</a><br /></td></tr>
<tr class="separator:aa68d8dd825fe1e2afe6ae76a3451f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa391f6b077d648470c71e5fd10bd1c77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa391f6b077d648470c71e5fd10bd1c77">naive</a></td></tr>
<tr class="memdesc:aa391f6b077d648470c71e5fd10bd1c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if O(n^2) naive search is being used.  <a href="#aa391f6b077d648470c71e5fd10bd1c77">More...</a><br /></td></tr>
<tr class="separator:aa391f6b077d648470c71e5fd10bd1c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2350329e79ee826a1a0bf5f998a69a16"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a2350329e79ee826a1a0bf5f998a69a16">oldFromNewReferences</a></td></tr>
<tr class="memdesc:a2350329e79ee826a1a0bf5f998a69a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutations of reference points during tree building.  <a href="#a2350329e79ee826a1a0bf5f998a69a16">More...</a><br /></td></tr>
<tr class="separator:a2350329e79ee826a1a0bf5f998a69a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae188a34bb4003b946f65319d4d353402"><td class="memItemLeft" align="right" valign="top">const MatType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ae188a34bb4003b946f65319d4d353402">referenceSet</a></td></tr>
<tr class="memdesc:ae188a34bb4003b946f65319d4d353402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference dataset. In some situations we may be the owner of this.  <a href="#ae188a34bb4003b946f65319d4d353402">More...</a><br /></td></tr>
<tr class="separator:ae188a34bb4003b946f65319d4d353402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa89993a2ba3ccec0068abdf0c992e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afa89993a2ba3ccec0068abdf0c992e62">referenceTree</a></td></tr>
<tr class="memdesc:afa89993a2ba3ccec0068abdf0c992e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root of the reference tree.  <a href="#afa89993a2ba3ccec0068abdf0c992e62">More...</a><br /></td></tr>
<tr class="separator:afa89993a2ba3ccec0068abdf0c992e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd3070fb70f2f35affe697009575796"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#adcd3070fb70f2f35affe697009575796">scores</a></td></tr>
<tr class="memdesc:adcd3070fb70f2f35affe697009575796"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of scores (applicable for non-naive search).  <a href="#adcd3070fb70f2f35affe697009575796">More...</a><br /></td></tr>
<tr class="separator:adcd3070fb70f2f35affe697009575796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0023bf70f4812bbecbea766f7fbb8ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac0023bf70f4812bbecbea766f7fbb8ae">searchMode</a></td></tr>
<tr class="memdesc:ac0023bf70f4812bbecbea766f7fbb8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the neighbor search mode.  <a href="#ac0023bf70f4812bbecbea766f7fbb8ae">More...</a><br /></td></tr>
<tr class="separator:ac0023bf70f4812bbecbea766f7fbb8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b455c873acbc3b47c6413268a8e39a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a91b455c873acbc3b47c6413268a8e39a">setOwner</a></td></tr>
<tr class="memdesc:a91b455c873acbc3b47c6413268a8e39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, we own the reference set.  <a href="#a91b455c873acbc3b47c6413268a8e39a">More...</a><br /></td></tr>
<tr class="separator:a91b455c873acbc3b47c6413268a8e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784d84f3b870ccd44e21b6717b68626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1784d84f3b870ccd44e21b6717b68626">singleMode</a></td></tr>
<tr class="memdesc:a1784d84f3b870ccd44e21b6717b68626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if single-tree search is being used (as opposed to dual-tree).  <a href="#a1784d84f3b870ccd44e21b6717b68626">More...</a><br /></td></tr>
<tr class="separator:a1784d84f3b870ccd44e21b6717b68626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79c0279ba6d78ed04c59a9109774d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#add79c0279ba6d78ed04c59a9109774d4">treeNeedsReset</a></td></tr>
<tr class="memdesc:add79c0279ba6d78ed04c59a9109774d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is true, the reference tree bounds need to be reset on a call to <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> without a query set.  <a href="#add79c0279ba6d78ed04c59a9109774d4">More...</a><br /></td></tr>
<tr class="separator:add79c0279ba6d78ed04c59a9109774d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ab4c317b79619050ba1936a4b57508"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a03ab4c317b79619050ba1936a4b57508">treeOwner</a></td></tr>
<tr class="memdesc:a03ab4c317b79619050ba1936a4b57508"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, this object created the trees and is responsible for them.  <a href="#a03ab4c317b79619050ba1936a4b57508">More...</a><br /></td></tr>
<tr class="separator:a03ab4c317b79619050ba1936a4b57508"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt;<br />
class mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;</h3>

<p>The <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> class is a template class for performing distance-based neighbor searches. </p>
<p>It takes a query dataset and a reference dataset (or just a reference dataset) and, for each point in the query dataset, finds the k neighbors in the reference dataset which have the 'best' distance according to a given sorting policy. A constructor is given which takes only a reference dataset, and if that constructor is used, the given reference dataset is also used as the query dataset.</p>
<p>The template parameters SortPolicy and Metric define the sort function used and the metric (distance function) used. More information on those classes can be found in the <a class="el" href="classmlpack_1_1neighbor_1_1NearestNeighborSort.html" title="This class implements the necessary methods for the SortPolicy template parameter of the NeighborSear...">NearestNeighborSort</a> class and the <a class="el" href="classmlpack_1_1kernel_1_1ExampleKernel.html" title="An example kernel function. ">kernel::ExampleKernel</a> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SortPolicy</td><td>The sort policy for distances; see <a class="el" href="classmlpack_1_1neighbor_1_1NearestNeighborSort.html" title="This class implements the necessary methods for the SortPolicy template parameter of the NeighborSear...">NearestNeighborSort</a>. </td></tr>
    <tr><td class="paramname">MetricType</td><td>The metric to use for computation. </td></tr>
    <tr><td class="paramname">MatType</td><td>The type of data matrix. </td></tr>
    <tr><td class="paramname">TreeType</td><td>The tree type to use; must adhere to the TreeType API. </td></tr>
    <tr><td class="paramname">DualTreeTraversalType</td><td>The type of dual tree traversal to use (defaults to the tree's default traverser). </td></tr>
    <tr><td class="paramname">SingleTreeTraversalType</td><td>The type of single tree traversal to use (defaults to the tree's default traverser). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00084">84</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3960fb4f9887fe8af0311808f0036819"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TreeType&lt;MetricType, <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchStat.html">NeighborSearchStat</a>&lt;SortPolicy&gt;, MatType&gt; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00088">88</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3d96c045b02d692f548ea81f4d8f818e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, passing a reference dataset (this is the dataset which is searched). </p>
<p>Optionally, perform the computation in a different mode. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p>
<p>This method will copy the matrices to internal copies, which are rearranged during tree-building. You can avoid this extra copy by pre-constructing the trees and passing them using a different constructor, or by using the construct that takes an rvalue reference to the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">mode</td><td>Neighbor search mode. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a352315dc48e3cb5c8fc8ef8b0baec4b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, taking ownership of the reference dataset (this is the dataset which is searched). </p>
<p>Optionally, perform the computation in a different mode. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p>
<p>This method will not copy the data matrix, but will take ownership of it, and depending on the type of tree used, may rearrange the points. If you would rather a copy be made, consider using the constructor that takes a const reference to the data instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">mode</td><td>Neighbor search mode. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af94774708c31c2b9c3f86135557224ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>referenceTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object with a copy of the given pre-constructed reference tree (this is the tree built on the points that will be searched). </p>
<p>Optionally, choose to use single-tree mode. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p>This method will copy the given tree. You can avoid this copy by using the construct that takes a rvalue reference to the tree.</p>
<dl class="section note"><dt>Note</dt><dd>Mapping the points of the matrix back to their original indices is not done when this constructor is used, so if the tree type you are using maps points (like BinarySpaceTree), then you will have to perform the re-mapping manually. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
    <tr><td class="paramname">mode</td><td>Neighbor search mode. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61596c37c527f077c651c3bf73cbb351"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object with the given pre-constructed reference tree (this is the tree built on the points that will be searched). </p>
<p>Optionally, choose to use single-tree mode. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p>This method will take ownership of the given tree. There is no copying of the data matrices (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p>
<dl class="section note"><dt>Note</dt><dd>Mapping the points of the matrix back to their original indices is not done when this constructor is used, so if the tree type you are using maps points (like BinarySpaceTree), then you will have to perform the re-mapping manually. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
    <tr><td class="paramname">mode</td><td>Neighbor search mode. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6c4a4e7f3f3f891d399eead8a1263f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58">DUAL_TREE_MODE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object without any reference data. </p>
<p>If <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> is called before a reference set is set with <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>, an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Neighbor search mode. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfd15ebef410145c5ca31f31fcfb0f3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, passing a reference dataset (this is the dataset which is searched). </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p>
<p>Deprecated. Will be removed in mlpack 3.0.0.</p>
<p>This method will copy the matrices to internal copies, which are rearranged during tree-building. You can avoid this extra copy by pre-constructing the trees and passing them using a different constructor, or by using the construct that takes an rvalue reference to the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">naive</td><td>If true, O(n^2) naive search will be used (as opposed to dual-tree search). This overrides singleMode (if it is set to true). </td></tr>
    <tr><td class="paramname">singleMode</td><td>If true, single-tree search will be used (as opposed to dual-tree search). </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92814d4bfcab403a41a94415c36070f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object, taking ownership of the reference dataset (this is the dataset which is searched). </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p>
<p>Deprecated. Will be removed in mlpack 3.0.0.</p>
<p>This method will not copy the data matrix, but will take ownership of it, and depending on the type of tree used, may rearrange the points. If you would rather a copy be made, consider using the constructor that takes a const reference to the data instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">naive</td><td>If true, O(n^2) naive search will be used (as opposed to dual-tree search). This overrides singleMode (if it is set to true). </td></tr>
    <tr><td class="paramname">singleMode</td><td>If true, single-tree search will be used (as opposed to dual-tree search). </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad157bab47d2b27e127611d7fb79249e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object with the given pre-constructed reference tree (this is the tree built on the points that will be searched). </p>
<p>Optionally, choose to use single-tree mode. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p>Deprecated. Will be removed in mlpack 3.0.0.</p>
<p>This method won't take ownership of the given tree. There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p>
<dl class="section note"><dt>Note</dt><dd>Mapping the points of the matrix back to their original indices is not done when this constructor is used, so if the tree type you are using maps points (like BinarySpaceTree), then you will have to perform the re-mapping manually. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c2b9e051ca9adfb74229cacd407b149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object without any reference data. </p>
<p>If <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> is called before a reference set is set with <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>, an exception will be thrown.</p>
<p>Deprecated. Will be removed in mlpack 3.0.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">naive</td><td>Whether to use naive search. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">epsilon</td><td>Relative approximate error (non-negative). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30023a0e353a6a304f18b3aed1f30a55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::~<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">NeighborSearch</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> object. </p>
<p>The tree is the only member we are responsible for deleting. The others will take care of themselves. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a33b2d3c5e13b408fec3341e209504cc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::BaseCases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of base case evaluations performed during the last search. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00498">498</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00575">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::baseCases</a>.</p>

</div>
</div>
<a class="anchor" id="aaf5280eb5e6feaa304dd7bf77badef73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::EffectiveError </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>foundDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>realDistances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the average relative error (effective error) between the distances calculated and the true distances provided. </p>
<p>The input matrices must have the same size.</p>
<p>Cases where the true distance is zero (the same point) or the calculated distance is SortPolicy::WorstDistance() (didn't find enough points) will be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foundDistances</td><td>Matrix storing lists of calculated distances for each query point. </td></tr>
    <tr><td class="paramname">realDistances</td><td>Matrix storing lists of true best distances for each query point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Average relative error. </dd></dl>

</div>
</div>
<a class="anchor" id="a64caddda792ac15e85bfc1c1a1995163"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Epsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the relative error to be considered in approximate search. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00531">531</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00569">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::epsilon</a>.</p>

</div>
</div>
<a class="anchor" id="ae56b2db591a2b76ab27dbc0227d1bfbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Epsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the relative error to be considered in approximate search. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00533">533</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00569">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::epsilon</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef7176ab3505a027964a6300b850f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Greedy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access whether or not search is done in greedy mode. </p>
<p>Deprecated. Will be replaced in mlpack 3.0.0, by a new method: NeighborSearchMode SearchMode(). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00524">524</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00567">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::greedy</a>.</p>

</div>
</div>
<a class="anchor" id="ac753548b72a735b04b076dc8c4f2b97d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Greedy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not search is done in greedy mode. </p>
<p>Deprecated. Will be replaced in mlpack 3.0.0, by a new method: NeighborSearchMode&amp; SearchMode(). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00528">528</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00567">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::greedy</a>.</p>

</div>
</div>
<a class="anchor" id="ac59851ea78f9623623023d2cc154efd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access whether or not search is done in naive linear scan mode. </p>
<p>Deprecated. Will be replaced in mlpack 3.0.0, by a new method: NeighborSearchMode SearchMode(). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00506">506</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00563">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::naive</a>.</p>

</div>
</div>
<a class="anchor" id="ac9d147bcd51799ae958d167bc351a5ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not search is done in naive linear scan mode. </p>
<p>Deprecated. Will be replaced in mlpack 3.0.0, by a new method: NeighborSearchMode&amp; SearchMode(). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00510">510</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00563">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::naive</a>.</p>

</div>
</div>
<a class="anchor" id="a2c91e05636e7122400313270feca1d12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Recall </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>foundNeighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>realNeighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the recall (% of neighbors found) given the list of found neighbors and the true set of neighbors. </p>
<p>The recall returned will be in the range [0, 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foundNeighbors</td><td>Matrix storing lists of calculated neighbors for each query point. </td></tr>
    <tr><td class="paramname">realNeighbors</td><td>Matrix storing lists of true best neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Recall. </dd></dl>

</div>
</div>
<a class="anchor" id="a6661389e9e9fdd662d36f347bc15945d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::ReferenceSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the reference dataset. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00536">536</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00553">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::referenceSet</a>.</p>

</div>
</div>
<a class="anchor" id="a94c87b9c41801e25320f418e21872c1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a>&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::ReferenceTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the reference tree. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00539">539</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00551">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::referenceTree</a>.</p>

</div>
</div>
<a class="anchor" id="aea8c3a20b9051e7f21b88bd7005317a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a>&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::ReferenceTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the reference tree. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00541">541</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00551">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::referenceTree</a>, and <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a86dcdd264303430172ec30ca4d313c53">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e18ff5e39676f0128916b72859d9f3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Scores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of node combination scores during the last search. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00501">501</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00577">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::scores</a>.</p>

</div>
</div>
<a class="anchor" id="aa38e2a58f4d4d93e43ffa5c26e5ac298"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>querySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each point in the query set, compute the nearest neighbors and store the output in the given matrices. </p>
<p>The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<p>If querySet contains only a few query points, the extra cost of building a tree on the points for dual-tree search may not be warranted, and it may be worthwhile to set singleMode = false (either in the constructor or with <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1ace3f909a89494c4c65110514f32662" title="Modify whether or not search is done in single-tree mode. ">SingleMode()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">querySet</td><td>Set of query points (can be just one point). </td></tr>
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ef823486a7fa2c583286212b5a0575f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *&#160;</td>
          <td class="paramname"><em>queryTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sameSet</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pre-built query tree, search for the nearest neighbors of each point in the query tree, storing the output in the given matrices. </p>
<p>The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<p>This method is deprecated and will be removed in mlpack 3.0.0! The <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> method taking a reference to the query tree is preferred.</p>
<p>Note that if you are calling <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> multiple times with a single query tree, you need to reset the bounds in the statistic of each query node, otherwise the result may be wrong! You can do this by calling TreeType::Stat()::Reset() on each node in the query tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree built on query points. </td></tr>
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
    <tr><td class="paramname">sameSet</td><td>Denotes whether or not the reference and query sets are the same. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab8c55603878488d69374f8475f11ce8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>queryTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sameSet</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pre-built query tree, search for the nearest neighbors of each point in the query tree, storing the output in the given matrices. </p>
<p>The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<p>Note that if you are calling <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> multiple times with a single query tree, you need to reset the bounds in the statistic of each query node, otherwise the result may be wrong! You can do this by calling TreeType::Stat()::Reset() on each node in the query tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree built on query points. </td></tr>
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
    <tr><td class="paramname">sameSet</td><td>Denotes whether or not the reference and query sets are the same. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ee72f753ad23efc31d16140b31481c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the nearest neighbors of every point in the reference set. </p>
<p>This is basically equivalent to calling any other overload of <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> with the reference set as the query set; so, this lets you do all-k-nearest-neighbors search. The results are stored in the given matrices. The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86dcdd264303430172ec30ca4d313c53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html" title="The NeighborSearch class is a template class for performing distance-based neighbor searches...">NeighborSearch</a> model. </p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00541">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::ReferenceTree()</a>.</p>

</div>
</div>
<a class="anchor" id="aa24b18a10831919d8ddca5cec8663fb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access whether or not search is done in single-tree mode. </p>
<p>Deprecated. Will be replaced in mlpack 3.0.0, by a new method: NeighborSearchMode SearchMode(). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00515">515</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00565">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::singleMode</a>.</p>

</div>
</div>
<a class="anchor" id="a1ace3f909a89494c4c65110514f32662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not search is done in single-tree mode. </p>
<p>Deprecated. Will be replaced in mlpack 3.0.0, by a new method: NeighborSearchMode&amp; SearchMode(). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00519">519</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>References <a class="el" href="neighbor__search_8hpp_source.html#l00565">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::singleMode</a>.</p>

</div>
</div>
<a class="anchor" id="afaef875683c28b8ef8089469757e819f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference set to a new reference set, and build a tree if necessary. </p>
<p>This method is called '<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a574193c2e26ca71af167d7c932bf51ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference set to a new reference set, taking ownership of the set, and build a tree if necessary. </p>
<p>This method is called '<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8db16866104befd4b5f7636e031ba26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="deprecated_8hpp.html#a3d7d5df477a8805980e43e423e18a525">mlpack_deprecated</a> void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference tree to a new reference tree. </p>
<p>This method is deprecated and will be removed in mlpack 3.0.0! <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a> methods taking a reference to the reference tree are preferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25f82c7dd2450941d8dc75ab1113a9af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>referenceTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference tree as a copy of the given reference tree. </p>
<p>This method will copy the given tree. You can avoid this copy by using the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#afaef875683c28b8ef8089469757e819f" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a> method that takes a rvalue reference to the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11324a983037f6e84526dfe709af5784"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference tree to a new reference tree. </p>
<p>This method will take ownership of the given tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab076be415133b12ba1417697563c9ff6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::UpdateSearchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates searchMode to be according to naive, singleMode and greedy booleans. </p>
<p>This is only necessary until the modifiers <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac9d147bcd51799ae958d167bc351a5ab" title="Modify whether or not search is done in naive linear scan mode. ">Naive()</a>, <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1ace3f909a89494c4c65110514f32662" title="Modify whether or not search is done in single-tree mode. ">SingleMode()</a> and <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac753548b72a735b04b076dc8c4f2b97d" title="Modify whether or not search is done in greedy mode. ">Greedy()</a> are removed in mlpack 3.0.0. </p>

</div>
</div>
<a class="anchor" id="a5f6b962adff1e42ca315ba38b67cbb08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::UpdateSearchModeFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates naive, singleMode and greedy flags according to searchMode. </p>
<p>This is only necessary until the modifiers <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac9d147bcd51799ae958d167bc351a5ab" title="Modify whether or not search is done in naive linear scan mode. ">Naive()</a>, <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a1ace3f909a89494c4c65110514f32662" title="Modify whether or not search is done in single-tree mode. ">SingleMode()</a> and <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#ac753548b72a735b04b076dc8c4f2b97d" title="Modify whether or not search is done in greedy mode. ">Greedy()</a> are removed in mlpack 3.0.0. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aee06866cee4bae43f4aaca591c5eb55c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::baseCases</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of base cases. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00575">575</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00498">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::BaseCases()</a>.</p>

</div>
</div>
<a class="anchor" id="a02d14564a86b37365a5aa6ff67d9f8f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::epsilon</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the relative error to be considered in approximate search. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00569">569</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00531">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Epsilon()</a>.</p>

</div>
</div>
<a class="anchor" id="a9cbcbe222f3ad8425f2a8045fc912e5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::greedy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if greedy search is being used. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00567">567</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00524">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Greedy()</a>.</p>

</div>
</div>
<a class="anchor" id="aa68d8dd825fe1e2afe6ae76a3451f44a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiation of metric. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00572">572</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa391f6b077d648470c71e5fd10bd1c77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::naive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if O(n^2) naive search is being used. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00563">563</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00506">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Naive()</a>.</p>

</div>
</div>
<a class="anchor" id="a2350329e79ee826a1a0bf5f998a69a16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::oldFromNewReferences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutations of reference points during tree building. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00549">549</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae188a34bb4003b946f65319d4d353402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType* <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::referenceSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference dataset. In some situations we may be the owner of this. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00553">553</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00536">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::ReferenceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="afa89993a2ba3ccec0068abdf0c992e62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#a3960fb4f9887fe8af0311808f0036819">Tree</a>* <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::referenceTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the root of the reference tree. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00551">551</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00539">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::ReferenceTree()</a>.</p>

</div>
</div>
<a class="anchor" id="adcd3070fb70f2f35affe697009575796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::scores</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of scores (applicable for non-naive search). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00577">577</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00501">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::Scores()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0023bf70f4812bbecbea766f7fbb8ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlpack_1_1neighbor.html#a77313e33f7e679dd62047c737e50be56">NeighborSearchMode</a> <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::searchMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the neighbor search mode. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00561">561</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91b455c873acbc3b47c6413268a8e39a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::setOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, we own the reference set. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00558">558</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1784d84f3b870ccd44e21b6717b68626"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::singleMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if single-tree search is being used (as opposed to dual-tree). </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00565">565</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="neighbor__search_8hpp_source.html#l00515">mlpack::neighbor::NeighborSearch&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::SingleMode()</a>.</p>

</div>
</div>
<a class="anchor" id="add79c0279ba6d78ed04c59a9109774d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::treeNeedsReset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this is true, the reference tree bounds need to be reset on a call to <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html#aa38e2a58f4d4d93e43ffa5c26e5ac298" title="For each point in the query set, compute the nearest neighbors and store the output in the given matr...">Search()</a> without a query set. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00581">581</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03ab4c317b79619050ba1936a4b57508"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree, template&lt; typename RuleType &gt; class DualTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template DualTreeTraverser, template&lt; typename RuleType &gt; class SingleTreeTraversalType = TreeType&lt;MetricType,                      NeighborSearchStat&lt;SortPolicy&gt;,                      MatType&gt;::template SingleTreeTraverser&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">mlpack::neighbor::NeighborSearch</a>&lt; SortPolicy, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType &gt;::treeOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, this object created the trees and is responsible for them. </p>

<p>Definition at line <a class="el" href="neighbor__search_8hpp_source.html#l00556">556</a> of file <a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/methods/neighbor_search/<a class="el" href="neighbor__search_8hpp_source.html">neighbor_search.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
<script type="text/javascript">
var x = document.getElementsByClassName("formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width /= 4;
}
</script>
</html>
