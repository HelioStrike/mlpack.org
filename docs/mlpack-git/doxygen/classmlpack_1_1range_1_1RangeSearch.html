<html >
<head >

<meta name="keywords" content="mlpack, libmlpack, c++, armadillo, machine
learning, data mining, classification, regression, tree-based methods, dual-tree
algorithm">
<meta name="description" content="mlpack: a scalable c++ machine learning
library">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title >mlpack: a scalable c++ machine learning library</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="dynamic_tables.js"></script>
</head><link rel="stylesheet" href="style-doxygen.css" /><link rel="stylesheet" href="doxygen.css" /><link rel="stylesheet" href="tabs.css" /><link rel="stylesheet" href="search/search.css" /><link href="http://fonts.googleapis.com/css?family=Maven+Pro:500" rel="stylesheet" type="text/css" />





<body ><br />


<div class="mlpack_titlebar">
   <a href="http://www.mlpack.org"><img src="../../../mlpack.png"></a>
</div>
<center >
<div class="mlnavbar">
  <div class="navcontainer">
   <div class="mlnavitem" name="mlnavmain"><a href="../../../index.html">main</a></div>
   <div class="mlnavitem" name="mlnavabout"><a href="../../../about.html">about</a></div>
   <div class="mlnavitem" name="mlnavdoc"><a href="../../../docs.html">docs</a></div>
   <div class="mlnavitem" name="mlnavhelp"><a href="../../../help.html">get help</a></div>
   <div class="mlnavitem" name="mlnavbugs"><a href="https://github.com/mlpack/mlpack">github</a></div>
  </div>
</div>
</center>
<div class="separator"></div>
<center >
<div class="mainsection smallertext">
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody >
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>

<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>

<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>


<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul >
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1range.html">range</a></li><li class="navelem"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a></li>  </ul>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlpack_1_1range_1_1RangeSearch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RangeSearch&lt; MetricType, MatType, TreeType &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">

<p >The <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> class is a template class for performing range searches.  
 <a href="classmlpack_1_1range_1_1RangeSearch.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5cbbe0e3dd87208f402ebd5a35dcd608"><td class="memItemLeft" align="right" valign="top">typedef TreeType&lt; MetricType, <a class="el" href="classmlpack_1_1range_1_1RangeSearchStat.html">RangeSearchStat</a>, MatType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a></td></tr>
<tr class="memdesc:a5cbbe0e3dd87208f402ebd5a35dcd608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef.  <a href="#a5cbbe0e3dd87208f402ebd5a35dcd608">More...</a><br /></br></td></tr>
<tr class="separator:a5cbbe0e3dd87208f402ebd5a35dcd608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a42c9883e2c3c767f79ead406ad475276"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a42c9883e2c3c767f79ead406ad475276">RangeSearch</a> (const MatType &amp;referenceSet, const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:a42c9883e2c3c767f79ead406ad475276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with a given reference dataset (this is the dataset which is searched).  <a href="#a42c9883e2c3c767f79ead406ad475276">More...</a><br /></br></td></tr>
<tr class="separator:a42c9883e2c3c767f79ead406ad475276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438e040b037d6a94c5427d6d7cd8d61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ad438e040b037d6a94c5427d6d7cd8d61">RangeSearch</a> (MatType &amp;&amp;referenceSet, const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:ad438e040b037d6a94c5427d6d7cd8d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given reference dataset (this is the dataset which is searched), taking ownership of the matrix.  <a href="#ad438e040b037d6a94c5427d6d7cd8d61">More...</a><br /></br></td></tr>
<tr class="separator:ad438e040b037d6a94c5427d6d7cd8d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d201f3cf484ea56a37daabeb0cded94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a6d201f3cf484ea56a37daabeb0cded94">RangeSearch</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *referenceTree, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:a6d201f3cf484ea56a37daabeb0cded94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched).  <a href="#a6d201f3cf484ea56a37daabeb0cded94">More...</a><br /></br></td></tr>
<tr class="separator:a6d201f3cf484ea56a37daabeb0cded94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838592644923cb86943f789ca0522bd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a838592644923cb86943f789ca0522bd1">RangeSearch</a> (const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:a838592644923cb86943f789ca0522bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object without any reference data.  <a href="#a838592644923cb86943f789ca0522bd1">More...</a><br /></br></td></tr>
<tr class="separator:a838592644923cb86943f789ca0522bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af751a5f912b2f3eb714567b6b6ca7c2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af751a5f912b2f3eb714567b6b6ca7c2d">RangeSearch</a> (const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;other)</td></tr>
<tr class="memdesc:af751a5f912b2f3eb714567b6b6ca7c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model as a copy of the given model.  <a href="#af751a5f912b2f3eb714567b6b6ca7c2d">More...</a><br /></br></td></tr>
<tr class="separator:af751a5f912b2f3eb714567b6b6ca7c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb192154ad7a75d89fcc6dbb6ffc1f24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#aeb192154ad7a75d89fcc6dbb6ffc1f24">RangeSearch</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aeb192154ad7a75d89fcc6dbb6ffc1f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model by taking ownership of the given model.  <a href="#aeb192154ad7a75d89fcc6dbb6ffc1f24">More...</a><br /></br></td></tr>
<tr class="separator:aeb192154ad7a75d89fcc6dbb6ffc1f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250641479dfc9c4881bdae8c960f767f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a250641479dfc9c4881bdae8c960f767f">~RangeSearch</a> ()</td></tr>
<tr class="memdesc:a250641479dfc9c4881bdae8c960f767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object.  <a href="#a250641479dfc9c4881bdae8c960f767f">More...</a><br /></br></td></tr>
<tr class="separator:a250641479dfc9c4881bdae8c960f767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4bd5d0aa64ea090796725f7755287d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3f4bd5d0aa64ea090796725f7755287d">BaseCases</a> () const</td></tr>
<tr class="memdesc:a3f4bd5d0aa64ea090796725f7755287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of base cases during the last search.  <a href="#a3f4bd5d0aa64ea090796725f7755287d">More...</a><br /></br></td></tr>
<tr class="separator:a3f4bd5d0aa64ea090796725f7755287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343230e7d7344e3f7d5f5f2eb89cf2c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a343230e7d7344e3f7d5f5f2eb89cf2c5">Naive</a> () const</td></tr>
<tr class="memdesc:a343230e7d7344e3f7d5f5f2eb89cf2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether naive search is being used.  <a href="#a343230e7d7344e3f7d5f5f2eb89cf2c5">More...</a><br /></br></td></tr>
<tr class="separator:a343230e7d7344e3f7d5f5f2eb89cf2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d397adca3f411b4e2d2f977b280ce6"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af7d397adca3f411b4e2d2f977b280ce6">Naive</a> ()</td></tr>
<tr class="memdesc:af7d397adca3f411b4e2d2f977b280ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether naive search is being used.  <a href="#af7d397adca3f411b4e2d2f977b280ce6">More...</a><br /></br></td></tr>
<tr class="separator:af7d397adca3f411b4e2d2f977b280ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0922f9fb5439cf21e6873f8a9a84b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a9b0922f9fb5439cf21e6873f8a9a84b5">operator=</a> (const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;other)</td></tr>
<tr class="memdesc:a9b0922f9fb5439cf21e6873f8a9a84b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model.  <a href="#a9b0922f9fb5439cf21e6873f8a9a84b5">More...</a><br /></br></td></tr>
<tr class="separator:a9b0922f9fb5439cf21e6873f8a9a84b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c57ee3bbf6708990e6432d0962e2226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a2c57ee3bbf6708990e6432d0962e2226">operator=</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a2c57ee3bbf6708990e6432d0962e2226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model.  <a href="#a2c57ee3bbf6708990e6432d0962e2226">More...</a><br /></br></td></tr>
<tr class="separator:a2c57ee3bbf6708990e6432d0962e2226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a975940b302b4efec85bbe2d8b36251"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0a975940b302b4efec85bbe2d8b36251">ReferenceSet</a> () const</td></tr>
<tr class="memdesc:a0a975940b302b4efec85bbe2d8b36251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference set.  <a href="#a0a975940b302b4efec85bbe2d8b36251">More...</a><br /></br></td></tr>
<tr class="separator:a0a975940b302b4efec85bbe2d8b36251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cb2297c084f56afea6f37e3c894f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a92cb2297c084f56afea6f37e3c894f52">ReferenceTree</a> ()</td></tr>
<tr class="memdesc:a92cb2297c084f56afea6f37e3c894f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference tree (or NULL if in naive mode).  <a href="#a92cb2297c084f56afea6f37e3c894f52">More...</a><br /></br></td></tr>
<tr class="separator:a92cb2297c084f56afea6f37e3c894f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1e40c0bf406280a237ca1b487e3c62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a4d1e40c0bf406280a237ca1b487e3c62">Scores</a> () const</td></tr>
<tr class="memdesc:a4d1e40c0bf406280a237ca1b487e3c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of scores during the last search.  <a href="#a4d1e40c0bf406280a237ca1b487e3c62">More...</a><br /></br></td></tr>
<tr class="separator:a4d1e40c0bf406280a237ca1b487e3c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df148abcabf67c5876e942e12279f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0df148abcabf67c5876e942e12279f8e">Search</a> (const MatType &amp;querySet, const <a class="el" href="namespacemlpack_1_1math.html#ad17d9cabd4fd82cbed4ccd5e53b47d70">math::Range</a> &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a0df148abcabf67c5876e942e12279f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects.  <a href="#a0df148abcabf67c5876e942e12279f8e">More...</a><br /></br></td></tr>
<tr class="separator:a0df148abcabf67c5876e942e12279f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0beece99aedbee1edf5890f5bc235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a24f0beece99aedbee1edf5890f5bc235">Search</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *queryTree, const <a class="el" href="namespacemlpack_1_1math.html#ad17d9cabd4fd82cbed4ccd5e53b47d70">math::Range</a> &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a24f0beece99aedbee1edf5890f5bc235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects.  <a href="#a24f0beece99aedbee1edf5890f5bc235">More...</a><br /></br></td></tr>
<tr class="separator:a24f0beece99aedbee1edf5890f5bc235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868480bcd41a740550657144b5f7018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3868480bcd41a740550657144b5f7018">Search</a> (const <a class="el" href="namespacemlpack_1_1math.html#ad17d9cabd4fd82cbed4ccd5e53b47d70">math::Range</a> &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a3868480bcd41a740550657144b5f7018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects.  <a href="#a3868480bcd41a740550657144b5f7018">More...</a><br /></br></td></tr>
<tr class="separator:a3868480bcd41a740550657144b5f7018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428c327df03391e32f8184b97f0cb5b7"><td class="memTemplParams" colspan="2"><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">Archive</div><div class="close_bracket">&gt;</div></div></div></div></td></tr>
<tr class="memitem:a428c327df03391e32f8184b97f0cb5b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a428c327df03391e32f8184b97f0cb5b7">Serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="memdesc:a428c327df03391e32f8184b97f0cb5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the model.  <a href="#a428c327df03391e32f8184b97f0cb5b7">More...</a><br /></br></td></tr>
<tr class="separator:a428c327df03391e32f8184b97f0cb5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7477b3e8499a6158bbe177e7f30d4947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a7477b3e8499a6158bbe177e7f30d4947">SingleMode</a> () const</td></tr>
<tr class="memdesc:a7477b3e8499a6158bbe177e7f30d4947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether single-tree search is being used.  <a href="#a7477b3e8499a6158bbe177e7f30d4947">More...</a><br /></br></td></tr>
<tr class="separator:a7477b3e8499a6158bbe177e7f30d4947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadacd63ddeadf138d834b1fdc632773"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adadacd63ddeadf138d834b1fdc632773">SingleMode</a> ()</td></tr>
<tr class="memdesc:adadacd63ddeadf138d834b1fdc632773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether single-tree search is being used.  <a href="#adadacd63ddeadf138d834b1fdc632773">More...</a><br /></br></td></tr>
<tr class="separator:adadacd63ddeadf138d834b1fdc632773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fd386abe263b5cf9461366485cb62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ad3fd386abe263b5cf9461366485cb62d">Train</a> (const MatType &amp;referenceSet)</td></tr>
<tr class="memdesc:ad3fd386abe263b5cf9461366485cb62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, and build a tree if necessary.  <a href="#ad3fd386abe263b5cf9461366485cb62d">More...</a><br /></br></td></tr>
<tr class="separator:ad3fd386abe263b5cf9461366485cb62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53a1056d8a4e4fae0049ba42b5e8dd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#aa53a1056d8a4e4fae0049ba42b5e8dd7">Train</a> (MatType &amp;&amp;referenceSet)</td></tr>
<tr class="memdesc:aa53a1056d8a4e4fae0049ba42b5e8dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, taking ownership of the set.  <a href="#aa53a1056d8a4e4fae0049ba42b5e8dd7">More...</a><br /></br></td></tr>
<tr class="separator:aa53a1056d8a4e4fae0049ba42b5e8dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1133fe6bda66e7143fd7aab27cbd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3d1133fe6bda66e7143fd7aab27cbd04">Train</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *referenceTree)</td></tr>
<tr class="memdesc:a3d1133fe6bda66e7143fd7aab27cbd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference tree to a new reference tree.  <a href="#a3d1133fe6bda66e7143fd7aab27cbd04">More...</a><br /></br></td></tr>
<tr class="separator:a3d1133fe6bda66e7143fd7aab27cbd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3 ><br /><div class="template_expr"><div class="template_decl">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">MetricType</div><div class="default_argument"><div class="equals">=</div><div class="identifier">metric::EuclideanDistance</div></div><div class="comma">,</div></div><div class="template_param"><div class="type_decl">typename</div><div class="identifier">MatType</div><div class="default_argument"><div class="equals">=</div><div class="identifier">arma::mat</div></div><div class="comma">,</div></div><div class="template_template_param"><div class="template">template</div><div class="open_bracket">&lt;</div><div class="template_param_list"><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeMetricType</div><div class="comma">,</div></div><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeStatType</div><div class="comma">,</div></div><div class="template_param"><div class="type_decl">typename</div><div class="identifier">TreeMatType</div><div class="close_bracket">&gt;</div></div></div><div class="template_template_param_name"><div class="type_decl">class</div><div class="identifier">TreeType</div><div class="default_argument"><div class="equals">=</div><div class="identifier">tree::KDTree</div></div><div class="close_bracket">&gt;</div></div></div></div></div></br>
class mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;</h3>

<p >The <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> class is a template class for performing range searches. </p>
<p >It is implemented in the style of a generalized tree-independent dual-tree algorithm; for more details on the actual algorithm, see the <a class="el" href="classmlpack_1_1range_1_1RangeSearchRules.html" title="The RangeSearchRules class is a template helper class used by RangeSearch class when performing range...">RangeSearchRules</a> class.</p>
<dl class="tparams"><dt >Template Parameters</dt><dd >
  <table class="tparams">
    <tr ><td class="paramname">MetricType</td><td >Metric to use for range search calculations. </td></tr>
    <tr ><td class="paramname">MatType</td><td >Type of data to use. </td></tr>
    <tr ><td class="paramname">TreeType</td><td >Type of tree to use; must satisfy the TreeType policy API. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00042">42</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5cbbe0e3dd87208f402ebd5a35dcd608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbbe0e3dd87208f402ebd5a35dcd608">&#9670;&nbsp;</a></span>Tree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">typedef TreeType&lt;MetricType, <a class="el" href="classmlpack_1_1range_1_1RangeSearchStat.html">RangeSearchStat</a>, MatType&gt; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Convenience typedef. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00046">46</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a42c9883e2c3c767f79ead406ad475276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c9883e2c3c767f79ead406ad475276">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >referenceSet</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >naive</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >singleMode</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em >metric</em> = <code >MetricType()</code>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with a given reference dataset (this is the dataset which is searched). </p>
<p >Optionally, perform the computation in naive mode or single-tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.</p>
<p >This method will copy the matrices to internal copies, which are rearranged during tree-building. You can avoid this extra copy by pre-constructing the trees and passing them using a different constructor.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">referenceSet</td><td >Reference dataset. </td></tr>
    <tr ><td class="paramname">naive</td><td >Whether the computation should be done in O(n^2) naive mode. </td></tr>
    <tr ><td class="paramname">singleMode</td><td >Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr ><td class="paramname">metric</td><td >Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad438e040b037d6a94c5427d6d7cd8d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438e040b037d6a94c5427d6d7cd8d61">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em >referenceSet</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >naive</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >singleMode</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em >metric</em> = <code >MetricType()</code>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given reference dataset (this is the dataset which is searched), taking ownership of the matrix. </p>
<p >Optionally, perform the computation in naive mode or single-tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.</p>
<p >This method will not copy the data matrix, but will take ownership of it, and depending on the type of tree used, may rearrange the points. If you would rather a copy be made, consider using the constructor that takes a const reference to the data instead.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">referenceSet</td><td >Set of reference points. </td></tr>
    <tr ><td class="paramname">naive</td><td >If true, brute force naive search will be used (as opposed to dual-tree search). This overrides singleMode (if it is set to true). </td></tr>
    <tr ><td class="paramname">singleMode</td><td >If true, single-tree search will be used (as opposed to dual-tree search). </td></tr>
    <tr ><td class="paramname">metric</td><td >An optional instance of the MetricType class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d201f3cf484ea56a37daabeb0cded94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d201f3cf484ea56a37daabeb0cded94">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td>
          <td class="paramname"><em >referenceTree</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >singleMode</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em >metric</em> = <code >MetricType()</code>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched). </p>
<p >Optionally, choose to use single-tree mode, which will not build a tree on query points. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p >There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p>
<dl class="section note"><dt >Note</dt><dd >Because tree-building (at least with BinarySpaceTree) modifies the ordering of a matrix, be aware that mapping of the points back to their original indices is not done when this constructor is used. </dd></dl>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">referenceTree</td><td >Pre-built tree for reference points. </td></tr>
    <tr ><td class="paramname">referenceSet</td><td >Set of reference points corresponding to referenceTree. </td></tr>
    <tr ><td class="paramname">singleMode</td><td >Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr ><td class="paramname">metric</td><td >Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838592644923cb86943f789ca0522bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838592644923cb86943f789ca0522bd1">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >naive</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em >singleMode</em> = <code >false</code>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em >metric</em> = <code >MetricType()</code>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object without any reference data. </p>
<p >If the monochromatic <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0df148abcabf67c5876e942e12279f8e" title="Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. ">Search()</a> is called before a reference set is set with <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ad3fd386abe263b5cf9461366485cb62d" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>, no results will be returned (since the reference set is empty).</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">naive</td><td >Whether to use naive search. </td></tr>
    <tr ><td class="paramname">singleMode</td><td >Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr ><td class="paramname">metric</td><td >Instantiated metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af751a5f912b2f3eb714567b6b6ca7c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af751a5f912b2f3eb714567b6b6ca7c2d">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model as a copy of the given model. </p>
<p >Note that this may be computationally intensive!</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">other</td><td ><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb192154ad7a75d89fcc6dbb6ffc1f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb192154ad7a75d89fcc6dbb6ffc1f24">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model by taking ownership of the given model. </p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">other</td><td ><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250641479dfc9c4881bdae8c960f767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250641479dfc9c4881bdae8c960f767f">&#9670;&nbsp;</a></span>~RangeSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">~<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Destroy the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object. </p>
<p >If trees were created, they will be deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f4bd5d0aa64ea090796725f7755287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4bd5d0aa64ea090796725f7755287d">&#9670;&nbsp;</a></span>BaseCases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">size_t BaseCases </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Get the number of base cases during the last search. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00313">313</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a343230e7d7344e3f7d5f5f2eb89cf2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343230e7d7344e3f7d5f5f2eb89cf2c5">&#9670;&nbsp;</a></span>Naive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">bool Naive </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Get whether naive search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00308">308</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="af7d397adca3f411b4e2d2f977b280ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d397adca3f411b4e2d2f977b280ce6">&#9670;&nbsp;</a></span>Naive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">bool&amp; Naive </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Modify whether naive search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00310">310</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a9b0922f9fb5439cf21e6873f8a9a84b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0922f9fb5439cf21e6873f8a9a84b5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&amp; operator= </td>
          <td >(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Copy the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model. </p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">other</td><td ><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c57ee3bbf6708990e6432d0962e2226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c57ee3bbf6708990e6432d0962e2226">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&amp; operator= </td>
          <td >(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em >other</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Take ownership of the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model. </p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">other</td><td ><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a975940b302b4efec85bbe2d8b36251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a975940b302b4efec85bbe2d8b36251">&#9670;&nbsp;</a></span>ReferenceSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">const MatType&amp; ReferenceSet </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the reference set. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00322">322</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a92cb2297c084f56afea6f37e3c894f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cb2297c084f56afea6f37e3c894f52">&#9670;&nbsp;</a></span>ReferenceTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a>* ReferenceTree </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Return the reference tree (or NULL if in naive mode). </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00325">325</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a4d1e40c0bf406280a237ca1b487e3c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1e40c0bf406280a237ca1b487e3c62">&#9670;&nbsp;</a></span>Scores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">size_t Scores </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Get the number of scores during the last search. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00315">315</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a428c327df03391e32f8184b97f0cb5b7">RangeSearch&lt; MetricType, MatType, TreeType &gt;::Serialize()</a>.</p>

</div>
</div>
<a id="a0df148abcabf67c5876e942e12279f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df148abcabf67c5876e942e12279f8e">&#9670;&nbsp;</a></span>Search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Search </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >querySet</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1math.html#ad17d9cabd4fd82cbed4ccd5e53b47d70">math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em >range</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em >neighbors</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em >distances</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. </p>
<p >Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p >That is:</p>
<ul >
<li >neighbors.size() and distances.size() both equal the number of query points.</li>
<li >neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li >distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li >neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">querySet</td><td >Set of query points to search with. </td></tr>
    <tr ><td class="paramname">range</td><td >Range of distances in which to search. </td></tr>
    <tr ><td class="paramname">neighbors</td><td >Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr ><td class="paramname">distances</td><td >Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f0beece99aedbee1edf5890f5bc235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f0beece99aedbee1edf5890f5bc235">&#9670;&nbsp;</a></span>Search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Search </td>
          <td >(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td>
          <td class="paramname"><em >queryTree</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1math.html#ad17d9cabd4fd82cbed4ccd5e53b47d70">math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em >range</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em >neighbors</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em >distances</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. </p>
<p >Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p >That is:</p>
<ul >
<li >neighbors.size() and distances.size() both equal the number of query points.</li>
<li >neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li >distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li >neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<p >If either naive or singleMode are set to true, this will throw an invalid_argument exception; passing in a query tree implies dual-tree search.</p>
<p >If you want to use the reference tree as the query tree, instead call the overload of <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0df148abcabf67c5876e942e12279f8e" title="Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. ">Search()</a> that does not take a query set.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">queryTree</td><td >Tree built on query points. </td></tr>
    <tr ><td class="paramname">range</td><td >Range of distances in which to search. </td></tr>
    <tr ><td class="paramname">neighbors</td><td >Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr ><td class="paramname">distances</td><td >Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3868480bcd41a740550657144b5f7018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868480bcd41a740550657144b5f7018">&#9670;&nbsp;</a></span>Search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Search </td>
          <td >(</td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1math.html#ad17d9cabd4fd82cbed4ccd5e53b47d70">math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em >range</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em >neighbors</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em >distances</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects. </p>
<p >This means that the query set and the reference set are the same.</p>
<p >Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p >That is:</p>
<ul >
<li >neighbors.size() and distances.size() both equal the number of query points.</li>
<li >neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li >distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li >neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">queryTree</td><td >Tree built on query points. </td></tr>
    <tr ><td class="paramname">range</td><td >Range of distances in which to search. </td></tr>
    <tr ><td class="paramname">neighbors</td><td >Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr ><td class="paramname">distances</td><td >Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a428c327df03391e32f8184b97f0cb5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c327df03391e32f8184b97f0cb5b7">&#9670;&nbsp;</a></span>Serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Serialize </td>
          <td >(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em >ar</em>, </td>
        </tr>
        <tr >
          <td class="paramkey"></td>
          <td ></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em >version</em>&#160;</td>
        </tr>
        <tr >
          <td ></td>
          <td >)</td>
          <td ></td><td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Serialize the model. </p>

<p class="reference">Referenced by <a class="el" href="range__search_8hpp_source.html#l00315">RangeSearch&lt; MetricType, MatType, TreeType &gt;::Scores()</a>.</p>

</div>
</div>
<a id="a7477b3e8499a6158bbe177e7f30d4947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7477b3e8499a6158bbe177e7f30d4947">&#9670;&nbsp;</a></span>SingleMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">bool SingleMode </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td > const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Get whether single-tree search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00303">303</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="adadacd63ddeadf138d834b1fdc632773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadacd63ddeadf138d834b1fdc632773">&#9670;&nbsp;</a></span>SingleMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr >
  <td class="mlabels-left">
      <table class="memname">
        <tr >
          <td class="memname">bool&amp; SingleMode </td>
          <td >(</td>
          <td class="paramname"></td><td >)</td>
          <td ></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p >Modify whether single-tree search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00305">305</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="ad3fd386abe263b5cf9461366485cb62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fd386abe263b5cf9461366485cb62d">&#9670;&nbsp;</a></span>Train() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Train </td>
          <td >(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em >referenceSet</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Set the reference set to a new reference set, and build a tree if necessary. </p>
<p >This method is called '<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ad3fd386abe263b5cf9461366485cb62d" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">referenceSet</td><td >New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa53a1056d8a4e4fae0049ba42b5e8dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53a1056d8a4e4fae0049ba42b5e8dd7">&#9670;&nbsp;</a></span>Train() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Train </td>
          <td >(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em >referenceSet</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Set the reference set to a new reference set, taking ownership of the set. </p>
<p >A tree is built if necessary. This method is called '<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ad3fd386abe263b5cf9461366485cb62d" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<dl class="params"><dt >Parameters</dt><dd >
  <table class="params">
    <tr ><td class="paramname">referenceSet</td><td >New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1133fe6bda66e7143fd7aab27cbd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1133fe6bda66e7143fd7aab27cbd04">&#9670;&nbsp;</a></span>Train() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr >
          <td class="memname">void Train </td>
          <td >(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td>
          <td class="paramname"><em >referenceTree</em></td><td >)</td>
          <td ></td>
        </tr>
      </table>
</div><div class="memdoc">

<p >Set the reference tree to a new reference tree. </p>

</div>
</div>
<hr ></hr>The documentation for this class was generated from the following file:<ul >
<li >src/mlpack/methods/range_search/<a class="el" href="range__search_8hpp_source.html">range_search.hpp</a></li>
</ul>
</div>

<hr class="footer"></hr><address class="footer"><small >
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"></img>
</a> 1.8.13
</small></address>
</div>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>